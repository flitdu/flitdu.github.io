<!DOCTYPE html><html lang="zh-CN//语言"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> ⭐️数据结构与算法之美（加餐） · Note</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="⭐️数据结构与算法之美（加餐） - Dufy"><meta name="keywords"><meta name="author" content="Dufy"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Note"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">⭐️数据结构与算法之美（加餐）</h1><div class="post-info">2021-04-04</div><div class="post-content"><a id="more"></a>

<h2 id="不定期福利第一期-数据结构与算法学习书单"><a href="#不定期福利第一期-数据结构与算法学习书单" class="headerlink" title="不定期福利第一期 | 数据结构与算法学习书单"></a>不定期福利第一期 | 数据结构与算法学习书单</h2><p>王争 2018-09-30</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d2959kj30vq0hsacb.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>你好，我是王争。欢迎来到不定期更新的周末福利时间。</p>
<p>专栏已经上线两周了，看到这么多人在留言区写下自己的疑惑或者观点，我特别开心。在留言里，很多同学让我推荐一些学习数据结构与算法的书籍。因此我特意跟编辑商量了，给你一个周末福利。所以这一期呢，我们就来聊一聊数据结构和算法学习过程中有哪些必读书籍。</p>
<p>有的同学还在读大学，代码还没写过几行；有的同学已经工作数十年，这之间的差别还是挺大的。而不同基础的人，适宜看的书是完全不一样的。因此，<strong>针对不同层次、不同语言的同学，我分别推荐了不同的书</strong>。希望每个同学，都能找到适合自己的学习资料，都能在现有水平上有所提高。</p>
<h3 id="针对入门的趣味书"><a href="#针对入门的趣味书" class="headerlink" title="针对入门的趣味书"></a>针对入门的趣味书</h3><p>入门的同学，我建议你不要过度追求上去就看经典书。像《算法导论》《算法》这些书，虽然比较经典、比较权威，但是非常厚。初学就去啃这些书肯定会很费劲。而一旦啃不下来，挫败感就会很强。所以，入门的同学，我建议你找一些比较容易看的书来看，比如《大话数据结构》和《算法图解》。<strong>不要太在意书写得深浅，重要的是能不能坚持看完。</strong></p>
<p>《<strong>大话数据结构</strong>》 这本书最大的特点是，它把理论讲得很有趣，不枯燥。而且每个数据结构和算法，作者都结合生活中的例子进行了讲解，能让你有非常直观的感受。虽然这本书有 400 多页，但是花两天时间读完，应该是没问题的。如果你之前完全不懂数据结构和算法，可以先从这本书看起。</p>
<p>《<strong>算法图解</strong>》 跟《大话数据结构》走的是同样的路线，就像这本书副标题写的那样，“像小说一样有趣的算法入门书”，主打“图解”，通俗易懂。它只有不到 200 页，所以内容比较少。作为入门，看看这本书，能让你对数据结构和算法有个大概的认识。</p>
<p>这些入门书共同的问题是，缺少细节，不够系统，也不够严谨。所以，如果你想要系统地学数据结构和算法，看这两本书肯定是不够的。</p>
<h3 id="针对特定编程语言的教科书"><a href="#针对特定编程语言的教科书" class="headerlink" title="针对特定编程语言的教科书"></a>针对特定编程语言的教科书</h3><p>讲数据结构和算法，肯定会跟代码实现挂钩。所以，很多人就很关心，某某书籍是用什么语言实现的，是不是自己熟悉的语言。市面大部分数据结构和算法书籍都是用 C、C++、Java 语言实现的，还有些是用伪代码。而使用 Python、Go、PHP、JavaScript、Objective-C 这些编程语言实现的就更少了。</p>
<p>我这里推荐《数据结构和算法分析》。国内外很多大学都拿这本书当作教材。这本书非常系统、全面、严谨，而且又不是特别难，适合对数据结构和算法有些了解，并且掌握了至少一门编程语言的同学。而且，这个作者也很用心。他用了三种语言，写了三个版本，分别是：《<strong>数据结构与算法分析 ：C 语言描述</strong>》《<strong>数据结构与算法分析：C++ 描述</strong>》《<strong>数据结构与算法分析：Java 语言描述</strong>》。</p>
<p>如果你熟悉的是 Python 或者 JavaScript，可以参考《<strong>数据结构与算法 JavaScript 描述</strong>》《<strong>数据结构与算法：Python 语言描述</strong>》 。至于其他语言的算法书籍，确实比较少。如果你有推荐，可以在留言区补充一下。</p>
<h3 id="面试必刷的宝典"><a href="#面试必刷的宝典" class="headerlink" title="面试必刷的宝典"></a>面试必刷的宝典</h3><p>算法对面试很重要，很多人也很关心。我这里推荐几本有益于面试的书籍，分别是：《剑指 offer》《编程珠玑》《编程之美》。</p>
<p>从《<strong>剑指 offer</strong>》这本书的名字就可以看出，作者的写作目的非常明确，就是为了面试。这本书几乎包含了所有常见的、经典的面试题。如果能搞懂这本书里的内容，应付一般公司的面试应该不成问题。</p>
<p>《<strong>编程珠玑</strong>》这本书的豆瓣评分非常高，有 9 分。这本书最大的特色就是讲了很多针对海量数据的处理技巧。这个可能是其他算法书籍很少涉及的。面试的时候，海量数据处理的问题也是经常会问的，特别是校招面试。不管是开拓眼界，还是应付面试，这本书都很值得一看。</p>
<p>《<strong>编程之美</strong>》这本书有多位作者，其中绝大部分是微软的工程师，所以书的质量很有保证。不过，这里面的算法题目稍微有点难，也不是很系统，这也是我把它归到面试这一部分的原因。如果你有一定基础，也喜欢钻研些算法问题，或者要面试 Google、Facebook 这样的公司，可以拿这本书里的题，先来自测一下。</p>
<h3 id="经典大部头"><a href="#经典大部头" class="headerlink" title="经典大部头"></a>经典大部头</h3><p>很多人一提到算法书就会搬出《算法导论》和《算法》。这两本确实非常经典，但是都太厚了，看起来比较费劲，我估计很少有人能坚持全部看下来。如果你想更加深入地学一学数据结构和算法，我还是强烈建议你看看。</p>
<p>我个人觉得，《<strong>算法导论</strong>》这本书的章节安排不是循序渐进的，里面充斥着各种算法的正确性、复杂度的证明、推导，数学公式比较多，一般人看起来会比较吃力。所以，作为入门书籍，并不是很推荐。</p>
<p>《<strong>算法</strong>》这本书也是一本经典大部头，不过它比起《算法导论》来要友好很多，更容易看懂，更适合初学者入门。但是这本书的缺点也很明显，就是内容不够全面，比如动态规划这么重要的知识点，这本书就没有讲。对于数据结构的东西，它讲的也不多，基本就是偏重讲算法。</p>
<h3 id="殿堂级经典"><a href="#殿堂级经典" class="headerlink" title="殿堂级经典"></a>殿堂级经典</h3><p>说到殿堂级经典书，如果《<strong>计算机程序设计艺术</strong>》称第二，我想没人敢称第一。这本书包括很多卷。说实话，我也只看过比较简单的几卷，比如《基本算法》《排序和查找》。</p>
<p>这套书的深度、广度、系统性、全面性是其他所有数据结构和算法书籍都无法相比的。但是，如果你对算法和数据结构不是特别感兴趣，没有很好的数学、算法、计算机基础，想要把这套书读完、读懂是比较难的。你可以把它当作你算法学习的终极挑战。</p>
<h3 id="闲暇阅读"><a href="#闲暇阅读" class="headerlink" title="闲暇阅读"></a>闲暇阅读</h3><p>算法无处不在。我这里再推荐几本适合闲暇时间阅读的书：《<strong>算法帝国</strong>》《<strong>数学之美</strong>》《<strong>算法之美</strong>》。</p>
<p>这些书共同的特点是，都列举了大量的例子，非常通俗易懂。夸张点说，像《算法帝国》，文科生都能读懂。当你看这些书的时候，你常常会深深感受到算法的力量，被算法的优美之处折服。即便不是从事 IT 工作的，看完这几本书也可以开拓眼界。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84cy0f32j30vq0na0x1.jpg" alt="img"></p>
<p>书籍差不多就是这些。除此之外，留言区很多人问到算法的实现语言。我这里也解释一下。因为我现在比较常用的编程语言是 Java。所以，在专栏里，特别简单的、不涉及高级语法的，我会用 Java 或者 C、C++ 来实现。稍微复杂的，为了让你能看懂，我会用伪代码。所以你完全不用担心语言的问题。</p>
<p>每节课中有需要代码实现的数据结构和算法，我都另外用 Java 语言实现一遍，然后放到 Github 上，供你参考。Github 的地址我放在这里，你可以收藏一下：<a href="https://github.com/wangzheng0822/algo。" target="_blank" rel="noopener">https://github.com/wangzheng0822/algo。</a></p>
<p>至于其他语言的同学，比如 C、C++、Python、Go、PHP、JavaScript、Objective-C 等，我想了一个 crowd sourcing 的方法。</p>
<p>我希望基础较好的同学，参照我的 Java 实现，用你熟悉的编程语言再实现一遍，并且将代码留言给我。如果你写得正确，我会将你的代码上传到 Github 上，分享给更多人。</p>
<p>还有人问，我学完这个专栏，就可以拿下数据结构和算法吗？我想说的是，<strong>每个人的基础、学习能力都不一样，掌握程度取决于你的努力程度</strong>。除了你之外，没有人能百分之百保证你能掌握什么知识。</p>
<p>有的同学只是把每一节课听下来、看下来，就束之高阁，也不求甚解，那效果肯定会很差。而有些同学除了听、看之外，遇到不懂的会自己去查资料、看参考书籍，还会把我讲的数据结构和算法都认真地实现一遍，这样的学习效果自然就比只听一遍、看一遍要好很多。即便我已经尽我所能把这些知识讲得深入浅出，通俗易懂，但是学习依然还是要靠你自己啊。</p>
<p>这种答疑的方式也会成为我们之后的固定动作，我会把留言里有价值的问题和反馈沉淀下来，希望对你的日常学习起到补充作用。<strong>如果你有什么看不懂、听不懂的地方，或者工作中有遇到算法问题、技术难题，欢迎写在留言区。</strong>（我发现留言区里卧虎藏龙啊，没事儿可以多扫扫留言区。）</p>
<p>这次的周末福利时间就到这啦，我们下次见！</p>
<h2 id="不定期福利第二期-王争：羁绊前行的，不是肆虐的狂风，而是内心的迷茫"><a href="#不定期福利第二期-王争：羁绊前行的，不是肆虐的狂风，而是内心的迷茫" class="headerlink" title="不定期福利第二期 | 王争：羁绊前行的，不是肆虐的狂风，而是内心的迷茫"></a>不定期福利第二期 | 王争：羁绊前行的，不是肆虐的狂风，而是内心的迷茫</h2><p>王争 2018-11-23</p>
<p><img src="https://static001.geekbang.org/resource/image/1f/85/1fca022ef82d07dcb93cd173026d7385.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>专栏更新过半，我发现有些小伙伴已经掉队，虽然有人掉队也挺正常，但是我还是想尽量拉一把。于是，周末的时间，我就在想，究竟是什么原因让有些小伙伴掉队了？是内容本身太难了吗？是我讲得不够清楚吗？还是小伙伴本身基础太差、不够努力、没有掌握学习方法？</p>
<p>我觉得都不是，让你掉队的原因，从根儿上讲，是你内心的迷茫。<strong>如果我们不那么确信能不能看懂、能不能学会的时候，当面对困难的时候，很容易就会否定自己，也就很容易半途而废</strong>。</p>
<p>这就好比你迷失在沙漠中，对你来说，肆虐的狂风并不可怕，可怕的是，你不知道该努力多久才能走出沙漠，不知道到底能不能走出沙漠。这种对结果的未知、不确定，导致了你内心的恐惧，最后就差那么一点点就可以走出沙漠的时候，你放弃了。</p>
<p>学习也是同样的道理。所以，<strong>我今天不打算讲学习方法，也不打算给你灌输心灵鸡汤，我就讲讲，对这个专栏的学习，或者对于任何学习来说，我觉得你应该建立的一些正确认知。</strong>有了这些认知，希望你能在后面的专栏学习中，少一点迷茫，多一份坚持。</p>
<h3 id="没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”"><a href="#没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”" class="headerlink" title="没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”"></a>没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp7wq9togjj30vq0k5adv.jpg" alt="img"></p>
<p>有小伙伴给我留言说：“看书五分钟，笔记两小时，急求学霸的学习方法”，还有人问，“数据结构和算法好难，到底该怎么学？是我的学习方法不对？还是我太笨？”</p>
<p>我想说，并没有什么杀手锏的学习方法，更没有一招致胜的“葵花宝典”。不知道这么说有没有让你失望。<strong>如果你真要“求”一个学习方法，那就再看看我在专栏开始写的“**</strong>如何抓住重点，系统高效地学习数据结构与算法<strong>**”那篇文章吧</strong>。</p>
<p>说实话，我也挺想知道学霸的学习方法的，所以，在求学路上，每当有学霸来分享学习方法，我都要去听一听。但是，听多了之后，我发现其实并没有太多用。因为那些所谓学霸的学习方法，其实都很简单，比如“认认真真听讲”“认认真真做每一道题”等等。</p>
<p>也不是他们说的不对，但是这种大实话，我总有一种领会不了的感觉，更别说真正指导我的学习了。而且，我觉得，很多时候，<strong>这些方法论的难点并不在于能不能听懂，而是在于能不能执行到位</strong>。比如很多人都听过“一万小时定律”，坚持一万个小时，你就能成为大牛，但有多少人能坚持一万个小时呢？</p>
<p>所以，这里我要纠正一个认知，那就是，学习没有“杀手锏”似的方法论。不要怀疑是不是自己的学习方法不对，不要在开始就否定自己。因为否定得越多，你就越迷茫，越不能坚持。</p>
<h3 id="不要浮躁，不要丧失思考能力，不要丧失学习能力"><a href="#不要浮躁，不要丧失思考能力，不要丧失学习能力" class="headerlink" title="不要浮躁，不要丧失思考能力，不要丧失学习能力"></a>不要浮躁，不要丧失思考能力，不要丧失学习能力</h3><p><img src="https://static001.geekbang.org/resource/image/8c/ca/8c1963cc2a871f4c2de8631d4f8684ca.jpg" alt="img"></p>
<p>有小伙伴给我留言说：“老师，这个地方看不懂，你能不能再解释一下”，还有小伙伴留言说：“《红黑树（上）》里的图为什么跟你的定义不相符？”</p>
<p>对于留言的问题，我都挺重视的，但是当仔细看这些问题的时候，我发现，实际上文章里已经有答案了，他根本没有认真看、认真思考，更别说去自己搜搜资料，再研究下，就来提问了。</p>
<p>一般情况下，我都会回复“你自己再认真看一遍”或者“你自己先去网上搜一下，研究研究，如果还不懂再给我留言”。告诉你答案，并不会花费我太长时间，但是，这样会让你丢失最宝贵的东西，那就是，你自己的思考能力、学习能力，能自己沉下心来研究的能力。这个是很可怕的。</p>
<p>现在，互联网如此发达，我们每天都会面对各种各样的信息轰炸，人也变得越来越浮躁。很多人习惯看些不动脑子就能看懂的东西，看到稍微复杂的东西，就感觉脑子转不动了。</p>
<p>上学的时候还好，要考试，有老师督促，还能坚持学习。但是工作之后，没有人监督，很多人陷入各种手机 App 中不能自拔，学一会儿就想玩会儿手机，想静下心来学上半个小时都无比困难。无法自律，沉不下心来，那你就基本可以跟学习说拜拜了。</p>
<h3 id="只有做好打硬仗的心理准备，遇到困难才能心态平和"><a href="#只有做好打硬仗的心理准备，遇到困难才能心态平和" class="headerlink" title="只有做好打硬仗的心理准备，遇到困难才能心态平和"></a>只有做好打硬仗的心理准备，遇到困难才能心态平和</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84deegnlj30vq0kln00.jpg" alt="img"></p>
<p>还有小伙伴给我留言说：“看不懂，一个 4000 多字的文章、10 分钟的音频，反复看了、听了 2 个小时都没怎么看懂”。我给他的回复是：“<strong>如果之前没有基础或者基础不好的话，看 2 个小时还不懂，很正常，看一个礼拜试试。</strong>”</p>
<p>“一个礼拜”的说法，我一点都不是夸张。虽然专栏的每篇文章都只有三四千字，10 分钟左右的音频，但是知识点的密度还是很高的。如果你潜意识里觉得应该一下子就能看懂，就会出现这样的情况：看了一遍不懂，又看了一遍还是不怎么懂，然后就放弃了。</p>
<p>数据结构和算法就是一个非常难啃的硬骨头，可以说是计算机学科中最难学的学科之一了。<strong>我当时学习也费了老大的劲，能做到讲给你听，我靠的也是十年如一的积累和坚持</strong>。如果没有基础、或者基础不好，你怎能期望看 2 个小时就能完全掌握呢？</p>
<p>面对这种硬骨头，我觉得我们要有打硬仗、打持久战的心理准备。只有这样，在学习的过程中遇到困难的时候，心态才能更加平和，才能沉下心来有条不紊地去解决一个个的疑难问题。这样，碰到问题，你可能还会“窃喜”，我又遇到了一个之前不怎么懂的知识点了，看懂它我又进步了一点。甚至你还会“坏坏地”想，又多了一个拉开我跟其他人距离的地方了。跨过这些点，我就能比别人更厉害。</p>
<p>一口吃不成胖子，如果你基础不好，那就从长计议吧，给自己定一个长一点的“死磕”计划，比如一年。面对不懂的知识点，沉下心来逐个突破，这样你的信心慢慢也就建立了。</p>
<h3 id="“放弃”的念头像是一个心魔，它会一直围绕着你"><a href="#“放弃”的念头像是一个心魔，它会一直围绕着你" class="headerlink" title="“放弃”的念头像是一个心魔，它会一直围绕着你"></a>“放弃”的念头像是一个心魔，它会一直围绕着你</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84cwvac1j30vq0jywhr.jpg" alt="img"></p>
<p>还有小伙伴给我留言说：“开始没怎么看懂，看了一下午，终于看懂了”。看到这样的留言，我其实挺为他感到庆幸的，庆幸他没有中途放弃。因为，放弃的念头就像一个心魔，在我们的学习过程中，它会一直围绕着我们，一旦被它打败一次，你就会被它打败很多次，掉队就不可避免了。</p>
<p>我分享一个我最近思考比较多的事情。前一段时间，我在研究多线程方面的东西，它涉及一块比较复杂的内容，“Java 内存模型”。虽然看懂并不难，但是要透彻、无盲点地理解并不容易。本来以为半天就能看懂的东西，结果我从周一一直看到周五下午，断断续续花了 5 天的时间才把它彻底搞懂。回忆起这 5 天，我有不下 10 次都想放弃，每次心里都在想：“算了，先放一放，以后再说吧”“太难了，啃不下来，算了。”“就这样吧，反正也用不到，没必要浪费时间”等等。这种放弃的念头就像一个邪恶的魔鬼一样，一直围绕着我这 5 天的研究中。</p>
<p>现在回想起来，我很庆幸我当时没有放弃，多坚持了几天。如果当时我放弃了，那之后再遇到技术难题时，“放弃”的心魔还会再来拜访我，潜意识里我还是会认输。</p>
<p>之所以没有放弃，我自己总结了两点原因。</p>
<p>第一，我对学习这件事情认识得比较清楚，我一直觉得，没有学不会的东西，没有攻克不了的技术难题，如果有，那就说明时间花得还不够多。</p>
<p>第二，我之前遇到卡壳的时候，几乎从来没有放弃过，即便短暂地停歇，我也会继续拎起来再死磕，而且每次都能搞定，正是这种正向的激励，给了我信心，让我再遇到困难的时候，都能坚信自己能搞定它。</p>
<h3 id="入门是一个非常漫长和煎熬的过程，谁都逃不过"><a href="#入门是一个非常漫长和煎熬的过程，谁都逃不过" class="headerlink" title="入门是一个非常漫长和煎熬的过程，谁都逃不过"></a>入门是一个非常漫长和煎熬的过程，谁都逃不过</h3><p><img src="https://static001.geekbang.org/resource/image/c3/67/c3db74036668f2d279e9a4a7b8468167.jpg" alt="img"></p>
<p>还有小伙伴留言说：“看到有小伙伴有很多疑问，我来帮作者说句话，文章写得很好，通俗易懂，如果有一定基础，看懂还是不成问题的。”</p>
<p>我觉得，有些小伙伴的觉悟还是挺高的：）。我文章写得再通俗易懂，对于之前没有任何基础的人来说，看起来还是挺费劲的。</p>
<p>第一，数据结构和算法这门课程本身的难度摆在那里，想要轻松看懂，本身就不太现实。第二，对于任何新知识的学习，入门都是一个非常漫长和煎熬的过程。但是这个过程都是要经历的，谁都逃不过。只要你挺过去，入了门，再学习更深的知识就简单多了。</p>
<p>我大学里的第一堂课是 C 语言，现在回想起来，当时对我来说，简直就是听天书。因为之前没有接触过计算机，更别说编程语言，对我来说，C 语言就像另一个世界的东西。从完全看不懂，到慢慢有点看懂，再到完全看懂，不夸张地讲，我花了好几年的时间，但是当掌握了之后，我发现这个东西其实也不难。但是如果没有度过漫长和煎熬的入门的过程，如果没有一点韧性，没有一点点信念，那可能也没有现在的我了。</p>
<p>其实我一直觉得<strong>情商比智商更重要</strong>。对于很多学科的学习，智商并不是瓶颈，最终能够决定你能达到的高度的，还是情商，而情商中最重要的，我觉得就是<strong>逆商</strong>（逆境商数，Adversity Quotient），也就是，<strong>当你遇到困难时，你会如何去面对，这将会决定你的人生最终能够走多远。</strong></p>
<p><img src="https://static001.geekbang.org/resource/image/56/c2/56db1ff64199a020ef376187f75304c2.jpg" alt="img"></p>
<p>好了，今天我想分享的关于学习的几个认知就讲完了。现在，你有没有对学习这件事有更加清晰的认识呢？能不能让你少一点迷茫，多一份坚持呢？</p>
<p>最后，我有一句送给你：吃得苦中苦，方为人上人。耐得住寂寞，才能守得住繁华。</p>
<h2 id="不定期福利第三期-测一测你的算法阶段学习成果"><a href="#不定期福利第三期-测一测你的算法阶段学习成果" class="headerlink" title="不定期福利第三期 | 测一测你的算法阶段学习成果"></a>不定期福利第三期 | 测一测你的算法阶段学习成果</h2><p>王争 2018-12-21</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp7wu2xk8qj30vq0hs41j.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>专栏最重要的基础篇马上就要讲完了，不知道你掌握了多少？我从前面的文章中挑选了一些案例，稍加修改，组成了一套测试题。</p>
<p>你先不要着急看答案，自己先想一想怎么解决，测一测自己对之前的知识掌握的程度。如果有哪里卡壳或者不怎么清楚的，可以回过头再复习一下。</p>
<p>正所谓温故知新，这种通过实际问题查缺补漏的学习方法，非常利于你巩固前面讲的知识点，你可要好好珍惜这次机会哦！</p>
<h3 id="实战测试题（一）"><a href="#实战测试题（一）" class="headerlink" title="实战测试题（一）"></a>实战测试题（一）</h3><p>假设猎聘网有 10 万名猎头顾问，每个猎头顾问都可以通过做任务（比如发布职位），来积累积分，然后通过积分来下载简历。<strong>假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：</strong></p>
<p>根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；</p>
<p>查找积分在某个区间的猎头 ID 列表；</p>
<p>查询积分从小到大排在第 x 位的猎头 ID 信息；</p>
<p>查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。</p>
<h3 id="相关章节"><a href="#相关章节" class="headerlink" title="相关章节"></a>相关章节</h3><p>17 | 跳表：为什么 Redis 一定要用跳表来实现有序集合？</p>
<p>20 | 散列表（下）：为什么散列表和链表经常会一起使用？</p>
<p>25 | 红黑树：为什么工程中都用红黑树这种二叉树？</p>
<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>这个问题既要通过 ID 来查询，又要通过积分来查询，所以，对于猎头这样一个对象，我们需要将其组织成两种数据结构，才能支持这两类操作。</p>
<p>我们按照 ID，将猎头信息组织成散列表。这样，就可以根据 ID 信息快速地查找、删除、更新猎头的信息。我们按照积分，将猎头信息组织成跳表这种数据结构，按照积分来查找猎头信息，就非常高效，时间复杂度是 O(logn)。</p>
<p>我刚刚讲的是针对第一个、第二个操作的解决方案。第三个、第四个操作是类似的，按照排名来查询，这两个操作该如何实现呢？</p>
<p>我们可以对刚刚的跳表进行改造，每个索引结点中加入一个 span 字段，记录这个索引结点到下一个索引结点的包含的链表结点的个数。这样就可以利用跳表索引，快速计算出排名在某一位的猎头或者排名在某个区间的猎头列表。</p>
<p>实际上，这些就是 Redis 中有序集合这种数据类型的实现原理。在开发中，我们并不需要从零开始代码实现一个散列表和跳表，我们可以直接利用 Redis 的有序集合来完成。</p>
<h3 id="实战测试题（二）"><a href="#实战测试题（二）" class="headerlink" title="实战测试题（二）"></a>实战测试题（二）</h3><p>电商交易系统中，订单数据一般都会很大，我们一般都分库分表来存储。假设我们分了 10 个库并存储在不同的机器上，在不引入复杂的分库分表中间件的情况下，我们希望开发一个小的功能，能够快速地查询金额最大的前 K 个订单（K 是输入参数，可能是 1、10、1000、10000，假设最大不会超过 10 万）。<strong>如果你是这个功能的设计开发负责人，你会如何设计一个比较详细的、可以落地执行的设计方案呢？</strong></p>
<p>为了方便你设计，我先交代一些必要的背景，在设计过程中，如果有其他需要明确的背景，你可以自行假设。</p>
<p>数据库中，订单表的金额字段上建有索引，我们可以通过 select order by limit 语句来获取数据库中的数据；</p>
<p>我们的机器的可用内存有限，比如只有几百 M 剩余可用内存。希望你的设计尽量节省内存，不要发生 Out of Memory Error。</p>
<h3 id="相关章节-1"><a href="#相关章节-1" class="headerlink" title="相关章节"></a>相关章节</h3><p>12 | 排序（下）：如何用快排思想在 O(n) 内查找第 K 大元素？</p>
<p>28 | 堆和堆排序：为什么说堆排序没有快速排序快？</p>
<p>29 | 堆的应用：如何快速获取到 Top 10 最热门的搜索关键词？</p>
<h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>解决这个题目的基本思路我想你应该能想到，就是借助归并排序中的合并函数，这个我们在排序（下）以及堆的应用那一节中讲过。</p>
<p>我们从每个数据库中，通过 select order by limit 语句，各取局部金额最大的订单，把取出来的 10 个订单放到优先级队列中，取出最大值（也就是大顶堆堆顶数据），就是全局金额最大的订单。然后再从这个全局金额最大订单对应的数据库中，取出下一条订单（按照订单金额从大到小排列的），然后放到优先级队列中。一直重复上面的过程，直到找到金额前 K（K 是用户输入的）大订单。</p>
<p>从算法的角度看起来，这个方案非常完美，但是，从实战的角度来说，这个方案并不高效，甚至很低效。因为我们忽略了，数据库读取数据的性能才是这个问题的性能瓶颈。所以，我们要尽量减少 SQL 请求，每次多取一些数据出来，那一次性取出多少才合适呢？这就比较灵活、比较有技巧了。一次性取太多，会导致数据量太大，SQL 执行很慢，还有可能触发超时，而且，我们题目中也说了，内存有限，太多的数据加载到内存中，还有可能导致 Out of Memory Error。</p>
<p>所以，一次性不能取太多数据，也不能取太少数据，到底是多少，还要根据实际的硬件环境做 benchmark 测试去找最合适的。</p>
<h3 id="实战测试题（三）"><a href="#实战测试题（三）" class="headerlink" title="实战测试题（三）"></a>实战测试题（三）</h3><p>我们知道，CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p>
<p><strong>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</strong></p>
<h3 id="相关章节-2"><a href="#相关章节-2" class="headerlink" title="相关章节"></a>相关章节</h3><p>09 | 队列：队列在线程池等有限资源池中的应用</p>
<h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>这个问题的答案涉及队列这种数据结构。队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</p>
<p>这个问题的具体答案，在队列那一节我已经讲得非常详细了，你可以回去看看，这里我就不赘述了。</p>
<h3 id="实战测试题（四）"><a href="#实战测试题（四）" class="headerlink" title="实战测试题（四）"></a>实战测试题（四）</h3><p>通过 IP 地址来查找 IP 归属地的功能，不知道你有没有用过？没用过也没关系，你现在可以打开百度，在搜索框里随便输一个 IP 地址，就会看到它的归属地。</p>
<p>这个功能并不复杂，它是通过维护一个很大的 IP 地址库来实现的。地址库中包括 IP 地址范围和归属地的对应关系。比如，当我们想要查询 202.102.133.13 这个 IP 地址的归属地时，我们就在地址库中搜索，发现这个 IP 地址落在[202.102.133.0, 202.102.133.255]这个地址范围内，那我们就可以将这个 IP 地址范围对应的归属地“山东东营市”显示给用户了。</p>
<p>[202.102.133.0, 202.102.133.255]  山东东营市 </p>
<p>[202.102.135.0, 202.102.136.255]  山东烟台 </p>
<p>[202.102.156.34, 202.102.157.255] 山东青岛 </p>
<p>[202.102.48.0, 202.102.48.255] 江苏宿迁 </p>
<p>[202.102.49.15, 202.102.51.251] 江苏泰州 </p>
<p>[202.102.56.0, 202.102.56.255] 江苏连云港</p>
<p>在庞大的地址库中逐一比对 IP 地址所在的区间，是非常耗时的。<strong>假设在内存中有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？</strong></p>
<h3 id="相关章节-3"><a href="#相关章节-3" class="headerlink" title="相关章节"></a>相关章节</h3><p>15 | 二分查找（上）：如何用最省内存的方式实现快速查找功能？</p>
<p>16 | 二分查找（下）：如何快速定位 IP 对应的省份地址？</p>
<h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>这个问题可以用二分查找来解决，不过，普通的二分查找是不行的，我们需要用到二分查找的变形算法，查找最后一个小于等于某个给定值的数据。不过，二分查找最难的不是原理，而是实现。要实现一个二分查找的变形算法，并且实现的代码没有 bug，可不是一件容易的事情，不信你自己写写试试。</p>
<p>关于这个问题的解答以及写出 bug free 的二分查找代码的技巧，我们在二分查找（下）那一节有非常详细的讲解，你可以回去看看，我这里就不赘述了。</p>
<h3 id="实战测试题（五）"><a href="#实战测试题（五）" class="headerlink" title="实战测试题（五）"></a>实战测试题（五）</h3><p>假设我们现在希望设计一个简单的海量图片存储系统，最大预期能够存储 1 亿张图片，并且希望这个海量图片存储系统具有下面这样几个功能：</p>
<p>存储一张图片及其它的元信息，主要的元信息有：图片名称以及一组 tag 信息。比如图片名称叫玫瑰花，tag 信息是{红色，花，情人节}；</p>
<p>根据关键词搜索一张图片，比如关键词是“情人节 花”“玫瑰花”；</p>
<p>避免重复插入相同的图片。这里，我们不能单纯地用图片的元信息，来比对是否是同一张图片，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。</p>
<p>我们希望自主开发一个简单的系统，不希望借助和维护过于复杂的三方系统，比如数据库（MySQL、Redis 等）、分布式存储系统（GFS、Bigtable 等），并且我们单台机器的性能有限，比如硬盘只有 1TB，内存只有 2GB，<strong>如何设计一个符合我们上面要求，操作高效，且使用机器资源最少的存储系统呢？</strong></p>
<h3 id="相关章节-4"><a href="#相关章节-4" class="headerlink" title="相关章节"></a>相关章节</h3><p>21 | 哈希算法（上）：如何防止数据库中的用户信息被脱库？</p>
<p>22 | 哈希算法（下）：哈希算法在分布式系统中有哪些应用？</p>
<h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>这个问题可以分成两部分，第一部分是根据元信息的搜索功能，第二部分是图片判重。</p>
<p>第一部分，我们可以借助搜索引擎中的倒排索引结构。关于倒排索引我会在实战篇详细讲解，我这里先简要说下。</p>
<p>如题目中所说，一个图片会对应一组元信息，比如玫瑰花对应{红色，花，情人节}，牡丹花对应{白色，花}，我们可以将这种图片与元信息之间的关系，倒置过来建立索引。“花”这个关键词对应{玫瑰花，牡丹花}，“红色”对应{玫瑰花}，“白色”对应{牡丹花}，“情人节”对应{玫瑰花}。</p>
<p>当我们搜索“情人节 花”的时候，我们拿两个搜索关键词分别在倒排索引中查找，“花”查找到了{玫瑰花，牡丹花}，“情人节”查找到了{玫瑰花}，两个关键词对应的结果取交集，就是最终的结果了。</p>
<p>第二部分关于图片判重，我们要基于图片本身来判重，所以可以用哈希算法，对图片内容取哈希值。我们对哈希值建立散列表，这样就可以通过哈希值以及散列表，快速判断图片是否存在。</p>
<p>我这里只说说我的思路，这个问题中还有详细的内存和硬盘的限制。要想给出更加详细的设计思路，还需要根据这些限制，给出一个估算。详细的解答，我都放在哈希算法（下）那一节里了，你可以自己回去看。</p>
<h3 id="实战测试题（六）"><a href="#实战测试题（六）" class="headerlink" title="实战测试题（六）"></a>实战测试题（六）</h3><p>我们知道，散列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。</p>
<p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。</p>
<p>如果散列表中有 10 万个数据，退化后的散列表查询的效率就下降了 10 万倍。更直观点说，如果之前运行 100 次查询只需要 0.1 秒，那现在就需要 1 万秒。这样就有可能因为查询操作消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。这也就是散列表碰撞攻击的基本原理。</p>
<p><strong>如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？</strong></p>
<h3 id="相关章节-5"><a href="#相关章节-5" class="headerlink" title="相关章节"></a>相关章节</h3><p>18 | 散列表（上）：Word 文档中的单词拼写检查功能是如何实现的？</p>
<p>19 | 散列表（中）：如何打造一个工业级水平的散列表？</p>
<h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>我经常把这道题拿来作为面试题考察候选人。散列表可以说是我们最常用的一种数据结构了，编程语言中很多数据类型，都是用散列表来实现的。尽管很多人能对散列表都知道一二，知道有几种散列表冲突解决方案，知道散列表操作的时间复杂度，但是理论跟实践还是有一定距离的。光知道这些基础的理论并不足以开发一个工业级的散列表。</p>
<p>所以，我在散列表（中）那一节中详细给你展示了一个工业级的散列表要处理哪些问题，以及如何处理的，也就是这个问题的详细答案。</p>
<p>这六道题你回答得怎么样呢？或许你还无法 100% 回答正确，没关系。其实只要你看了解析之后，有比较深的印象，能立马想到哪节课里讲过，这已经说明你掌握得不错了。毕竟想要完全掌握我讲的全部内容还是需要时间沉淀的。对于这门课的学习，你一定不要心急，慢慢来。只要方向对了就都对了，剩下就交给时间和努力吧！</p>
<p>通过这套题，你对自己的学习状况应该有了一个了解。从专栏开始到现在，三个月过去了，我们的内容也更新了大半。<strong>你在专栏开始的时候设定的目标是什么？现在实施得如何了？**</strong>你可以在留言区给这三个月的学习做个<strong>**阶段性学习复盘</strong>。重新整理，继续出发！</p>
<h2 id="不定期福利第四期-刘超：我是怎么学习《数据结构与算法之美》的？"><a href="#不定期福利第四期-刘超：我是怎么学习《数据结构与算法之美》的？" class="headerlink" title="不定期福利第四期 | 刘超：我是怎么学习《数据结构与算法之美》的？"></a>不定期福利第四期 | 刘超：我是怎么学习《数据结构与算法之美》的？</h2><p>刘超 2018-12-28</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d3pag8j30vq0hs788.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>你好，我是刘超，是隔壁《趣谈网络协议》专栏的作者。今天来“串个门儿”，讲讲我学习《数据结构与算法之美》这个专栏的一些体会和感受。</p>
<p>《数据结构与算法之美》是目前“极客时间”订阅量最多的专栏，我也是其中最早购买的一员。我之所以一看就心动了，源于王争老师在开篇词里面说的那段话：</p>
<p>基础知识就像是一座大楼的地基，它决定了我们的技术高度。那技术人究竟都需要修炼哪些“内功”呢？我觉得，无外乎就是大学里的那些基础课程，操作系统、计算机网络、编译原理等等，当然还有数据结构和算法。</p>
<p>这个也是我写《趣谈网络协议》的时候，在开篇词里反复强调的观点。我为什么这么说呢？因为，我们作为面试官，在招人的时候，往往发现，使用框架速成的人很多，基础知识扎实的人少见，而基础不扎实会影响你以后学习新技术的速度和职业发展的广度。</p>
<p>和“极客时间”编辑聊的时候，我也多次表达，希望我们讲的东西和一般的培训机构有所区别，希望“极客时间”能做真正对程序员的技能提升和职业发展有价值的内容，希望“极客时间”能够成为真正帮助程序员成长的助手。</p>
<p>所以，当“极客时间”相继推出《Java 核心技术 36 讲》《零基础学 Python》《从 0 开始学架构》《MySQL 实战 45 讲》这些课程的时候，我非常开心。我希望将来能够继续覆盖到编译原理、操作系统、计算机组成原理等等。在这些课程里，算法是基础的基础，也是我本人很想精进的部分。</p>
<p>当然，除了长远的职业发展需要，搞定算法还有一个看得见、摸得着的好处，面试。</p>
<p>我经常讲，越是薪资低的企业，面试的时候，它们往往越注重你会不会做网站，甚至会要求你现场做出个东西来。你要注意了，这其实是在找代码熟练工。相反，越是薪资高的企业，越是重视考察基础知识。基础好，说明可塑性强，培养起来也比较快。<strong>而最牛的公司，考的往往是算法和思路。</strong></p>
<p>相信很多购买《数据结构与算法之美》专栏的同学，下单的时候，已经想象自己面试的时候，在白板上挥洒代码，面试官频频点头的场景，想着自己马上就能“进驻牛公司，迎娶白富美”了。</p>
<p>然而，事实却是，<strong>武功套路容易学，扎马步基本功难练</strong>，编程也是一样。框架容易学，基本功难。你没办法讨巧，你要像郭靖学习降龙十八掌那样，一掌一掌劈下去才行。</p>
<p>于是，咱们这个专栏就开始了，你见到的仍然是困难的复杂度计算，指针指来指去，烧脑的逻辑，小心翼翼的边界条件判断。你发现，数据结构和算法好像并不是你上下班时间顺便听一听就能攻克的问题。你需要静下心来仔细想，拿个笔画一画，甚至要写一写代码，Debug 一下，才能够理解。是的，的确不轻松，那你坚持下来了吗？</p>
<p>我在这里分享一下我的学习思路，我将这个看起来困难的过程分成了几部分来完成。</p>
<p>第一部分，数据结构和算法的基础知识部分。如果在大学学过这门课，在专栏里，你会看到很多熟悉的描述。有些基础比较好的同学会质疑写这些知识的必要性。这大可不必，因为每个人的基础不一样，为了专栏内容的系统性和完整性，老师肯定要把这些基础知识重新讲述一遍的。对于这一部分内容，如果你的基础比较好，可以像学其他课程一样，在上下班或者午休的时候进行学习，主要是起到温习的作用。</p>
<p>第二部分，需要代码练习的部分。由于王争老师面试过很多人，所以在专栏里，他会列举一些他在面试中常常会问的题目。很多情况下，这些题目需要当场就能在白板上写出来。这些问题对于想要提升自己面试能力的同学来说，应该是很有帮助的。</p>
<p>我这里列举几个，你可以看看，是不是都能回答出来呢？</p>
<p>在链表这一节：单链表反转，链表中环的检测，两个有序的链表合并，删除链表倒数第 n 个结点，求链表的中间结点等。</p>
<p>在栈这一节，在函数调用中的应用，在表达式求值中的应用，在括号匹配中的应用。</p>
<p>在排序这一节，如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？</p>
<p>在二分查找这一节，二分查找的四个变体。</p>
<p>这些问题你都应该上手写写代码，或者在面试之前拿来练练手，而且，不仅仅只是实现主要功能。大公司的面试很多情况下都会考虑边界条件。只要被面试官抓住漏洞，就会被扣分，所以你最好事先写写。</p>
<p>第三部分，对于海量数据的处理思路问题。现在排名靠前的大公司，大都存在海量数据的处理问题。对于这一类问题，在面试的时候，也是经常会问到的。由于这类问题复杂度比较高，很少让当场就写代码，但是基本上会让你说一个思路，或者写写伪代码。想要解决海量数据的问题，你会的就不能只是基础的数据结构和算法了，你需要综合应用。如果平时没有想过这部分问题，临时被问，肯定会懵。</p>
<p>在专栏里，王争老师列举了大量这类问题，你要重点思考这类问题背后的思路，然后平时自己处理问题的时候，也多想想，如果这个问题数据量大的话，应该怎么办。这样多思考，面试的时候，思路很容易就来了。</p>
<p>比如，我这里随便列了几个，都是很经典的问题。你要是想不起来，就赶紧去复习吧！</p>
<p>比如说，我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？</p>
<p>如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？</p>
<p>假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</p>
<p>假设我们有 1000 万个整型数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？</p>
<p>第四部分，工业实践部分。在每种数据结构的讲解中，老师会重点分析一些这些数据结构在工业上的实践，封装在库里面的，一般人不注意的。</p>
<p>我看王争老师也是个代码分析控。一般同学可能遇到问题，查一查有没有开源软件或者现成的库，可以用就完了。而王争老师会研究底层代码的实现，解析为什么这些在工业中大量使用的库，应该这样实现。这部分不但对于面试有帮助，对于实际开发也有很大的帮助。普通程序员和高手的差距，就是一个用完了就完了，一个用完了要看看为啥这样用。</p>
<p>例如，老师解析了 Glibc 中的 qsort() 函数，Java 中的 HashMap 如何实现工业级的散列表，Redis 中的有序集合（Sorted Set）的实现，工程上使用的红黑树等等。</p>
<p>尤其是对于哈希算法，老师解析了安全加密、数据校验、唯一标识、散列函数，负载均衡、数据分片、分布式存储等应用。如果你同时订阅了架构、微服务的课程，你会发现这些算法在目前最火的架构设计中，都有使用。</p>
<p>师傅领进门，修行在个人。尽管老师只是解析了其中一部分，但是咱们在平时使用开源软件和库的时候，也要多问个为什么。写完了程序，看看官方文档，看看原理解析的书，看看源代码，然后映射到算法与数据结构中，你会发现，这些知识和思路到处都在使用。</p>
<p>最后，我还想说一句，坚持，别放弃，啃下来。基础越扎实，路走得越远，走得越宽。加油！</p>
<h2 id="总结课-在实际开发中，如何权衡选择使用哪种数据结构和算法？"><a href="#总结课-在实际开发中，如何权衡选择使用哪种数据结构和算法？" class="headerlink" title="总结课 | 在实际开发中，如何权衡选择使用哪种数据结构和算法？"></a>总结课 | 在实际开发中，如何权衡选择使用哪种数据结构和算法？</h2><p>王争 2019-02-18</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d4go78j30vq0hsq5b.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p></p>
<p>00:00</p>
<p><a href="javascript:;" target="_blank" rel="noopener">1.25x<em></em></a></p>
<p>讲述：冯永吉 大小：9.47M 时长：10:20</p>
<p>你好，我是王争，今天是一篇总结课。我们学了这么多数据结构和算法，在实际开发中，究竟该如何权衡选择使用哪种数据结构和算法呢？今天我们就来聊一聊这个问题，希望能帮你把学习带回实践中。</p>
<p>我一直强调，学习数据结构和算法，不要停留在学院派的思维中，只把算法当作应付面试、考试或者竞赛的花拳绣腿。作为软件开发工程师，我们要把数据结构和算法，应用到软件开发中，解决实际的开发问题。</p>
<p>不过，要想在实际的开发中，灵活、恰到好处地应用数据结构和算法，需要非常深厚的实战经验积累。尽管我在课程中，一直都结合实际的开发场景来讲解，希望带你真枪实弹地演练算法如何解决实际的问题。但是，在今后的软件开发中，你要面对的问题远比我讲的场景要复杂、多变、不确定。</p>
<p>要想游刃有余地解决今后你要面对的问题，光是熟知每种数据结构和算法的功能、特点、时间空间复杂度，还是不够的。毕竟工程上的问题不是算法题。算法题的背景、条件、限制都非常明确，我们只需要在规定的输入、输出下，找最优解就可以了。</p>
<p>而工程上的问题往往都比较开放，在选择数据结构和算法的时候，我们往往需要综合各种因素，比如编码难度、维护成本、数据特征、数据规模等，最终选择一个<strong>工程的最合适解</strong>，而非<strong>理论上的最优解</strong>。</p>
<p>为了让你能做到活学活用，在实际的软件开发中，不生搬硬套数据结构和算法，今天，我们就聊一聊，在实际的软件开发中，如何权衡各种因素，合理地选择使用哪种数据结构和算法？关于这个问题，我总结了六条经验。</p>
<h3 id="1-时间、空间复杂度不能跟性能划等号"><a href="#1-时间、空间复杂度不能跟性能划等号" class="headerlink" title="1. 时间、空间复杂度不能跟性能划等号"></a>1. 时间、空间复杂度不能跟性能划等号</h3><p>我们在学习每种数据结构和算法的时候，都详细分析了算法的时间复杂度、空间复杂度，但是，在实际的软件开发中，复杂度不能与性能简单划等号，不能表示执行时间和内存消耗的确切数据量。为什么这么说呢？原因有下面几点。</p>
<p><strong>复杂度不是执行时间和内存消耗的精确值</strong></p>
<p>在用大 O 表示法表示复杂度的时候，我们会忽略掉低阶、常数、系数，只保留高阶，并且它的度量单位是语句的执行频度。每条语句的执行时间，并非是相同、确定的。所以，复杂度给出的只能是一个非精确量值的趋势。</p>
<p><strong>代码的执行时间有时不跟时间复杂度成正比</strong></p>
<p>我们常说，时间复杂度是 O(nlogn) 的算法，比时间复杂度是 O(n^2) 的算法，执行效率要高。这样说的一个前提是，算法处理的是大规模数据的情况。对于小规模数据的处理，算法的执行效率并不一定跟时间复杂度成正比，有时还会跟复杂度成反比。</p>
<p><strong>对于处理不同问题的不同算法，其复杂度大小没有可比性</strong></p>
<p>复杂度只能用来表征不同算法，在处理同样的问题，以及同样数据类型的情况下的性能表现。但是，对于不同的问题、不同的数据类型，不同算法之间的复杂度大小并没有可比性。</p>
<h3 id="2-抛开数据规模谈数据结构和算法都是“耍流氓”"><a href="#2-抛开数据规模谈数据结构和算法都是“耍流氓”" class="headerlink" title="2. 抛开数据规模谈数据结构和算法都是“耍流氓”"></a>2. 抛开数据规模谈数据结构和算法都是“耍流氓”</h3><p>在平时的开发中，在数据规模很小的情况下，普通算法和高级算法之间的性能差距会非常小。如果代码执行频率不高、又不是核心代码，这个时候，我们选择数据结构和算法的主要依据是，其是否简单、容易维护、容易实现。大部分情况下，我们直接用最简单的存储结构和最暴力的算法就可以了。</p>
<p>比如，对于长度在一百以内的字符串匹配，我们直接使用朴素的字符串匹配算法就够了。如果用 KMP、BM 这些更加高效的字符串匹配算法，实际上就大材小用了。因为这对于处理时间是毫秒量级敏感的系统来说，性能的提升并不大。相反，这些高级算法会徒增编码的难度，还容易产生 bug。</p>
<h3 id="3-结合数据特征和访问方式来选择数据结构"><a href="#3-结合数据特征和访问方式来选择数据结构" class="headerlink" title="3. 结合数据特征和访问方式来选择数据结构"></a>3. 结合数据特征和访问方式来选择数据结构</h3><p>面对实际的软件开发场景，当我们掌握了基础数据结构和算法之后，最考验能力的并不是数据结构和算法本身，而是对问题需求的挖掘、抽象、建模。<strong>如何将一个背景复杂、开放的问题，通过细致的观察、调研、假设，理清楚要处理数据的特征与访问方式，这才是解决问题的重点。</strong>只有理清楚了这些东西，我们才能将问题转化成合理的数据结构模型，进而找到满足需求的算法。</p>
<p>比如我们前面讲过，Trie 树这种数据结构是一种非常高效的字符串匹配算法。但是，如果你要处理的数据，并没有太多的前缀重合，并且字符集很大，显然就不适合利用 Trie 树了。所以，在用 Trie 树之前，我们需要详细地分析数据的特点，甚至还要写些分析代码、测试代码，明确要处理的数据是否适合使用 Trie 树这种数据结构。</p>
<p>再比如，图的表示方式有很多种，邻接矩阵、邻接表、逆邻接表、二元组等等。你面对的场景应该用哪种方式来表示，具体还要看你的数据特征和访问方式。如果每个数据之间联系很少，对应到图中，就是一个稀疏图，就比较适合用邻接表来存储。相反，如果是稠密图，那就比较适合采用邻接矩阵来存储。</p>
<h3 id="4-区别对待-IO-密集、内存密集和计算密集"><a href="#4-区别对待-IO-密集、内存密集和计算密集" class="headerlink" title="4. 区别对待 IO 密集、内存密集和计算密集"></a>4. 区别对待 IO 密集、内存密集和计算密集</h3><p>如果你要处理的数据存储在磁盘，比如数据库中。那代码的性能瓶颈有可能在磁盘 IO，而并非算法本身。这个时候，你需要合理地选择数据存储格式和存取方式，减少磁盘 IO 的次数。</p>
<p>比如我们在递归那一节讲过最终推荐人的例子。你应该注意到了，当时我给出的代码尽管正确，但其实并不高效。如果某个用户是经过层层推荐才来注册的，那我们获取他的最终推荐人的时候，就需要多次访问数据库，性能显然就不高了。</p>
<p>不过，这个问题解决起来不难。我们知道，某个用户的最终推荐人一旦确定，就不会变动。所以，我们可以离线计算每个用户的最终推荐人，并且保存在表中的某个字段里。当我们要查看某个用户的最终推荐人的时候，访问一次数据库就可以获取到。</p>
<p>刚刚我们讲了数据存储在磁盘的情况，现在我们再来看下，数据存储在内存中的情况。如果你的数据是存储在内存中，那我们还需要考虑，代码是内存密集型的还是 CPU 密集型的。</p>
<p>所谓 CPU 密集型，简单点理解就是，代码执行效率的瓶颈主要在 CPU 执行的效率。我们从内存中读取一次数据，到 CPU 缓存或者寄存器之后，会进行多次频繁的 CPU 计算（比如加减乘除），CPU 计算耗时占大部分。所以，在选择数据结构和算法的时候，要尽量减少逻辑计算的复杂度。比如，用位运算代替加减乘除运算等。</p>
<p>所谓内存密集型，简单点理解就是，代码执行效率的瓶颈在内存数据的存取。对于内存密集型的代码，计算操作都比较简单，比如，字符串比较操作，实际上就是内存密集型的。每次从内存中读取数据之后，我们只需要进行一次简单的比较操作。所以，内存数据的读取速度，是字符串比较操作的瓶颈。因此，在选择数据结构和算法的时候，需要考虑是否能减少数据的读取量，数据是否在内存中连续存储，是否能利用 CPU 缓存预读。</p>
<h3 id="5-善用语言提供的类，避免重复造轮子"><a href="#5-善用语言提供的类，避免重复造轮子" class="headerlink" title="5. 善用语言提供的类，避免重复造轮子"></a>5. 善用语言提供的类，避免重复造轮子</h3><p>实际上，对于大部分常用的数据结构和算法，编程语言都提供了现成的类和函数实现。比如，Java 中的 HashMap 就是散列表的实现，TreeMap 就是红黑树的实现等。在实际的软件开发中，除非有特殊的要求，我们都可以直接使用编程语言中提供的这些类或函数。</p>
<p>这些编程语言提供的类和函数，都是经过无数验证过的，不管是正确性、鲁棒性，都要超过你自己造的轮子。而且，你要知道，重复造轮子，并没有那么简单。你需要写大量的测试用例，并且考虑各种异常情况，还要团队能看懂、能维护。这显然是一个出力不讨好的事情。这也是很多高级的数据结构和算法，比如 Trie 树、跳表等，在工程中，并不经常被应用的原因。</p>
<p>但这并不代表，学习数据结构和算法是没用的。深入理解原理，有助于你能更好地应用这些编程语言提供的类和函数。能否深入理解所用工具、类的原理，这也是普通程序员跟技术专家的区别。</p>
<h3 id="6-千万不要漫无目的地过度优化"><a href="#6-千万不要漫无目的地过度优化" class="headerlink" title="6. 千万不要漫无目的地过度优化"></a>6. 千万不要漫无目的地过度优化</h3><p>掌握了数据结构和算法这把锤子，不要看哪里都是钉子。比如，一段代码执行只需要 0.01 秒，你非得用一个非常复杂的算法或者数据结构，将其优化成 0.005 秒。即便你的算法再优秀，这种微小优化的意义也并不大。相反，对应的代码维护成本可能要高很多。</p>
<p>不过度优化并不代表，我们在软件开发的时候，可以不加思考地随意选择数据结构和算法。我们要学会估算。估算能力实际上也是一个非常重要的能力。我们不仅要对普通情况下的数据规模和性能压力做估算，还需要对异常以及将来一段时间内，可能达到的数据规模和性能压力做估算。这样，我们才能做到未雨绸缪，写出来的代码才能经久可用。</p>
<p>还有，当你真的要优化代码的时候，一定要先做 Benchmark 基准测试。这样才能避免你想当然地换了一个更高效的算法，但真实情况下，性能反倒下降了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>工程上的问题，远比课本上的要复杂。所以，我今天总结了六条经验，希望你能把数据结构和算法用在刀刃上，恰当地解决实际问题。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d7c0o1j30vq0mn0x1.jpg" alt="img"></p>
<p>我们在利用数据结构和算法解决问题的时候，一定要先分析清楚问题的需求、限制、隐藏的特点等。只有搞清楚了这些，才能有针对性地选择恰当的数据结构和算法。这种灵活应用的实战能力，需要长期的刻意锻炼和积累。这是一个有经验的工程师和一个学院派的工程师的区别。</p>
<p>好了，今天的内容就到这里了。最后，我想听你谈一谈，你在实际开发选择数据结构和算法时，有什么感受和方法呢？</p>
<p>欢迎在留言区写下你的想法，也欢迎你把今天的文章分享给你的朋友，帮助他在数据结构和算法的实际运用中走得更远。</p>
<h2 id="《数据结构与算法之美》学习指导手册"><a href="#《数据结构与算法之美》学习指导手册" class="headerlink" title="《数据结构与算法之美》学习指导手册"></a>《数据结构与算法之美》学习指导手册</h2><p>王争 2019-04-22</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp7wxcgewaj30vq0hs7a5.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>你好，我是王争。</p>
<p>在设计专栏内容的时候，为了兼顾不同基础的同学，我在内容上做到了难易结合，既有简单的数组、链表、栈、队列这些基础内容，也有红黑树、BM、KMP 这些难度较大的算法。但是，对于初学者来说，一下子面对这么多知识，可能还是比较懵。</p>
<p>我觉得，对于初学者来说，先把最简单、最基础、最重要的知识点掌握好，再去研究难度较高、更加高级的知识点，这样由易到难、循序渐进的学习路径，无疑是最合理的。</p>
<p>基于这个路径，我对专栏内容，重新做了一次梳理，希望给你一份具体、明确、有效的学习指导。我会写清楚<strong>每个知识点的难易程度、需要你掌握到什么程度、具体如何来学习</strong>。</p>
<p>如果你是数据结构和算法的初学者，或者你觉得自己的基础比较薄弱，希望这份学习指导，能够让你学起来能更加有的放矢，能把精力、时间花在刀刃上，获得更好的学习效果。</p>
<p>下面，我先给出一个大致的学习路线。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d6ioopj31400u0gri.jpg" alt="img"></p>
<p>（建议保存后查看大图）</p>
<p>现在，针对每个知识点，我再给你逐一解释一下。我这里先说明一下，下面标记的难易程度、是否重点、掌握程度，都只是针对初学者来说的，如果你已经有一定基础，可以根据自己的情况，安排自己的学习。</p>
<h3 id="1-复杂度分析"><a href="#1-复杂度分析" class="headerlink" title="1. 复杂度分析"></a>1. 复杂度分析</h3><p>尽管在专栏中，我只用了两节课的内容，来讲复杂度分析这个知识点。但是，我想说的是，它真的非常重要。你必须要牢牢掌握这两节，基本上要做到，简单代码能很快分析出时间、空间复杂度；对于复杂点的代码，比如递归代码，你也要掌握专栏中讲到的两种分析方法：递推公式和递归树。</p>
<p>对于初学者来说，光看入门篇的两节复杂度分析文章，可能还不足以完全掌握复杂度分析。不过，在后续讲解每种数据结构和算法的时候，我都有详细分析它们的时间、空间复杂度。所以，你可以在学习专栏中其他章节的时候，再不停地、有意识地去训练自己的复杂度分析能力。</p>
<p>难易程度：Medium</p>
<p>是否重点：10 分</p>
<p>掌握程度：在不看我的分析的情况下，能自行分析专栏中大部分数据结构和算法的时间、空间复杂度</p>
<h3 id="2-数组、栈、队列"><a href="#2-数组、栈、队列" class="headerlink" title="2. 数组、栈、队列"></a>2. 数组、栈、队列</h3><p>这一部分内容非常简单，初学者学起来也不会很难。但是，作为基础的数据结构，数组、栈、队列，是后续很多复杂数据结构和算法的基础，所以，这些内容你一定要掌握。</p>
<p>难易程度：Easy</p>
<p>是否重点：8 分</p>
<p>掌握程度：能自己实现动态数组、栈、队列</p>
<h3 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h3><p>链表非常重要！虽然理论内容不多，但链表上的操作却很复杂。所以，面试中经常会考察，你一定要掌握。而且，我这里说“掌握”不只是能看懂专栏中的内容，还能将专栏中提到的经典链表题目，比如链表反转、求中间结点等，轻松无 bug 地实现出来。</p>
<p>难易程度：Medium</p>
<p>是否重点：9 分</p>
<p>掌握程度：能轻松写出经典链表题目代码</p>
<h3 id="4-递归"><a href="#4-递归" class="headerlink" title="4. 递归"></a>4. 递归</h3><p>对于初学者来说，递归代码非常难掌握，不管是读起来，还是写起来。但是，这道坎你必须要跨过，跨不过就不能算是入门数据结构和算法。我们后面讲到的很多数据结构和算法的代码实现，都要用到递归。</p>
<p>递归相关的理论知识也不多，所以还是要多练。你可以先在网上找些简单的题目练手，比如斐波那契数列、求阶乘等，然后再慢慢过渡到更加有难度的，比如归并排序、快速排序、二叉树的遍历、求高度，最后是回溯八皇后、背包问题等。</p>
<p>难易程度：Hard</p>
<p>是否重点：10 分</p>
<p>掌握程度：轻松写出二叉树遍历、八皇后、背包问题、DFS 的递归代码</p>
<h3 id="5-排序、二分查找"><a href="#5-排序、二分查找" class="headerlink" title="5. 排序、二分查找"></a>5. 排序、二分查找</h3><p>这一部分并不难，你只需要能看懂我专栏里的内容即可。</p>
<p>难易程度：Easy</p>
<p>是否重点：7 分</p>
<p>掌握程度：能自己把各种排序算法、二分查找及其变体代码写一遍就可以了</p>
<h3 id="6-跳表"><a href="#6-跳表" class="headerlink" title="6. 跳表"></a>6. 跳表</h3><p>对于初学者来说，并不需要非得掌握跳表，所以，如果没有精力，这一章节可以先跳过。</p>
<p>难易程度：Medium</p>
<p>是否重点：6 分</p>
<p>掌握程度：初学者可以先跳过。如果感兴趣，看懂专栏内容即可，不需要掌握代码实现</p>
<h3 id="7-散列表"><a href="#7-散列表" class="headerlink" title="7. 散列表"></a>7. 散列表</h3><p>尽管散列表的内容我讲了很多，有三节课。但是，总体上来讲，这块内容理解起来并不难。但是，作为一种应用非常广泛的数据结构，你还是要掌握牢固散列表。</p>
<p>难易程度：Medium</p>
<p>是否重点：8 分</p>
<p>掌握程度：对于初学者来说，自己能代码实现一个拉链法解决冲突的散列表即可</p>
<h3 id="8-哈希算法"><a href="#8-哈希算法" class="headerlink" title="8. 哈希算法"></a>8. 哈希算法</h3><p>这部分纯粹是为了开拓思路，初学者可以略过。</p>
<p>难易程度：Easy</p>
<p>是否重点：3 分</p>
<p>掌握程度：可以暂时不看</p>
<h3 id="9-二叉树"><a href="#9-二叉树" class="headerlink" title="9. 二叉树"></a>9. 二叉树</h3><p>这一部分非常重要！二叉树在面试中经常会被考到，所以要重点掌握。但是我这里说的二叉树，并不包含专栏中红黑树的内容。红黑树我们待会再讲。</p>
<p>难易程度：Medium</p>
<p>是否重点：9 分</p>
<p>掌握程度：能代码实现二叉树的三种遍历算法、按层遍历、求高度等经典二叉树题目</p>
<h3 id="10-红黑树"><a href="#10-红黑树" class="headerlink" title="10. 红黑树"></a>10. 红黑树</h3><p>对于初学者来说，这一节课完全可以不看。</p>
<p>难易程度：Hard</p>
<p>是否重点：3 分</p>
<p>掌握程度：初学者不用把时间浪费在上面</p>
<h3 id="11-B-树"><a href="#11-B-树" class="headerlink" title="11. B+ 树"></a>11. B+ 树</h3><p>虽然 B+ 树也算是比较高级的一种数据结构了，但是对初学者来说，也不是重点。有时候面试的时候还是会问的，所以这一部分内容，你能看懂专栏里的讲解就可以了。</p>
<p>难易程度：Medium</p>
<p>是否重点：5 分</p>
<p>掌握程度：可看可不看</p>
<h3 id="12-堆与堆排序"><a href="#12-堆与堆排序" class="headerlink" title="12. 堆与堆排序"></a>12. 堆与堆排序</h3><p>这一部分内容不是很难，初学者也是要掌握的。</p>
<p>难易程度：Medium</p>
<p>是否重点：8 分</p>
<p>掌握程度：能代码实现堆、堆排序，并且掌握堆的三种应用（优先级队列、Top k、中位数）</p>
<h3 id="13-图的表示"><a href="#13-图的表示" class="headerlink" title="13. 图的表示"></a>13. 图的表示</h3><p>图的内容很多，但是初学者不需要掌握那么多。一般 BAT 等大厂面试，不怎么会面试有关图的内容，因为面试官可能也对这块不会很熟悉哈：）。但是，最基本图的概念、表示方法还是要掌握的。</p>
<p>难易程度：Easy</p>
<p>是否重点：8 分</p>
<p>掌握程度：理解图的三种表示方法（邻接矩阵、邻接表、逆邻接表），能自己代码实现</p>
<h3 id="14-深度广度优先搜索"><a href="#14-深度广度优先搜索" class="headerlink" title="14. 深度广度优先搜索"></a>14. 深度广度优先搜索</h3><p>这算是图上最基础的遍历或者说是搜索算法了，所以还是要掌握一下。这两种算法的原理都不难哈，但是代码实现并不简单，一个用到了队列，另一个用到了递归。对于初学者来说，看懂这两个代码实现就是一个挑战！可以等到其他更重要的内容都掌握之后，再来挑战，也是可以的。</p>
<p>难易程度：Hard</p>
<p>是否重点：8 分</p>
<p>掌握程度：能代码实现广度优先、深度优先搜索算法</p>
<h3 id="15-拓扑排序、最短路径、A-算法"><a href="#15-拓扑排序、最短路径、A-算法" class="headerlink" title="15. 拓扑排序、最短路径、A* 算法"></a>15. 拓扑排序、最短路径、A* 算法</h3><p>这几个算法稍微高级点。如果你能轻松实现深度、广度优先搜索，那看懂这三个算法不成问题。不过，这三种算法不是重点。面试不会考的。</p>
<p>难易程度：Hard</p>
<p>是否重点：5 分</p>
<p>掌握程度：有时间再看，暂时可以不看</p>
<h3 id="16-字符串匹配（BF、RK）"><a href="#16-字符串匹配（BF、RK）" class="headerlink" title="16. 字符串匹配（BF、RK）"></a>16. 字符串匹配（BF、RK）</h3><p>BF 非常简单，RK 稍微复杂点，但都不难。这个最好还是掌握下。</p>
<p>难易程度：Easy</p>
<p>是否重点：7 分</p>
<p>掌握程度：能实践 BF 算法，能看懂 RK 算法</p>
<h3 id="17-字符串匹配（BM、KMP、AC-自动机）"><a href="#17-字符串匹配（BM、KMP、AC-自动机）" class="headerlink" title="17. 字符串匹配（BM、KMP、AC 自动机）"></a>17. 字符串匹配（BM、KMP、AC 自动机）</h3><p>这三个算法都挺难的，对于算法有一定基础的人来说，看懂也不容易。所以，对于初学者来说，千万别浪费时间在这上面。即便有余力，看懂就好了，不用非得能自己实现。</p>
<p>难易程度：Hard</p>
<p>是否重点：3 分</p>
<p>掌握程度：初学者不用把时间浪费在上面</p>
<h3 id="18-字符串匹配（Trie）"><a href="#18-字符串匹配（Trie）" class="headerlink" title="18. 字符串匹配（Trie）"></a>18. 字符串匹配（Trie）</h3><p>这个还是要能看懂，不过不需要能代码实现。有些面试官喜欢考这个东西，主要是结合应用场景来考察，只是看你知不知道要用 Trie 树这个东西。</p>
<p>难易程度：Medium</p>
<p>是否重点：7 分</p>
<p>掌握程度：能看懂，知道特点、应用场景即可，不要求代码实现</p>
<h3 id="19-位图"><a href="#19-位图" class="headerlink" title="19. 位图"></a>19. 位图</h3><p>位图不是重点，如果有余力最好掌握一下。</p>
<p>难易程度：Easy</p>
<p>是否重点：6 分</p>
<p>掌握程度：看懂即可，能自己实现一个位图结构最好</p>
<h3 id="20-四种算法思想"><a href="#20-四种算法思想" class="headerlink" title="20. 四种算法思想"></a>20. 四种算法思想</h3><p>这个是重点，也是难点。贪心、分治、回溯、动态规划，每一个都不简单，其中动态规划又是最难、最烧脑的。要应付 FLAG 这样公司的面试，必须拿下这块内容。但是呢，学习要循序渐进，这块内容的学习可以放到最后，做个长时间的学习计划来攻克。</p>
<p>这块内容理论的东西不多，要想真的掌握，还是要大量刷题。</p>
<p>难易程度：Hard</p>
<p>是否重点：10 分</p>
<p>掌握程度：可以放到最后，但是一定要掌握！做到能实现 Leetcode 上 Medium 难度的题目</p>
<p>学而时习之，专栏虽然已经结束，但是学习的同学和留言依旧源源不断。希望这份学习指导手册对你有帮助，也欢迎你继续给我留言，和大家一起交流、学习、进步。</p>
<hr>
<h2 id="春节7天练-Day-1：数组和链表"><a href="#春节7天练-Day-1：数组和链表" class="headerlink" title="春节7天练 | Day 1：数组和链表"></a>春节7天练 | Day 1：数组和链表</h2><p>王争 2019-02-04</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84cx7hn5j30vq0jywhr.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>讲述：冯永吉 大小：882.20K 时长：00:55</p>
<p>你好，我是王争。首先祝你新年快乐！</p>
<p>专栏的正文部分已经结束，相信这半年的时间，你学到了很多，究竟学习成果怎样呢？</p>
<p>我整理了数据结构和算法中必知必会的 30 个代码实现，从今天开始，分 7 天发布出来，供你复习巩固所用。你可以每天花一点时间，来完成测验。测验完成后，你可以根据结果，回到相应章节，有针对性地进行复习。</p>
<p>除此之外，@Smallfly 同学还整理了一份配套的 LeetCode 练习题，你也可以一起练习一下。在此，我谨代表我本人对 @Smallfly 表示感谢！</p>
<p>另外，我还为假期坚持学习的同学准备了丰厚的春节加油礼包。</p>
<p>2 月 5 日 -2 月 14 日，只要在专栏文章下的留言区写下你的答案，参与答题，并且留言被精选，即可获得极客时间 10 元无门槛优惠券。</p>
<p>7 篇中的所有题目，只要回答正确 3 道及以上，即可获得极客时间 99 元专栏通用阅码。</p>
<p>如果 7 天连续参与答题，并且每天的留言均被精选，还可额外获得极客时间价值 365 元的每日一课年度会员。</p>
<h3 id="关于数组和链表的几个必知必会的代码实现"><a href="#关于数组和链表的几个必知必会的代码实现" class="headerlink" title="关于数组和链表的几个必知必会的代码实现"></a>关于数组和链表的几个必知必会的代码实现</h3><ul>
<li><strong>数组</strong></li>
</ul>
<p>实现一个支持动态扩容的数组</p>
<p>实现一个大小固定的有序数组，支持动态增删改操作</p>
<p>实现两个有序数组合并为一个有序数组</p>
<ul>
<li><strong>链表</strong></li>
</ul>
<p>实现单链表、循环链表、双向链表，支持增删操作</p>
<p>实现单链表反转</p>
<p>实现两个有序的链表合并为一个有序链表</p>
<p>实现求链表的中间结点</p>
<h3 id="对应的-LeetCode-练习题（-Smallfly-整理）"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><ul>
<li><strong>数组</strong></li>
</ul>
<p>Three Sum（求三数之和）</p>
<p>英文版：<a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum/</a></p>
<p>Majority Element（求众数）</p>
<p>英文版：<a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">https://leetcode.com/problems/majority-element/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/majority-element/</a></p>
<p>Missing Positive（求缺失的第一个正数）</p>
<p>英文版：<a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">https://leetcode.com/problems/first-missing-positive/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-missing-positive/</a></p>
<ul>
<li><strong>链表</strong></li>
</ul>
<p>Linked List Cycle I（环形链表）</p>
<p>英文版：<a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a></p>
<p>Merge k Sorted Lists（合并 k 个排序链表）</p>
<p>英文版：<a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-k-sorted-lists/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p>
<p>做完题目之后，你可以点击“请朋友读”，把测试题分享给你的朋友，说不定就帮他解决了一个难题。</p>
<p>祝你取得好成绩！明天见！</p>
<h2 id="春节7天练-Day-2：栈、队列和递归"><a href="#春节7天练-Day-2：栈、队列和递归" class="headerlink" title="春节7天练 | Day 2：栈、队列和递归"></a>春节7天练 | Day 2：栈、队列和递归</h2><p>王争 2019-02-05</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp7wjor9n4j30vq0hsn0z.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>你好，我是王争。初二好！</p>
<p>为了帮你巩固所学，真正掌握数据结构和算法，我整理了数据结构和算法中，必知必会的 30 个代码实现，分 7 天发布出来，供你复习巩固所用。今天是第二篇。</p>
<p>和昨天一样，你可以花一点时间，来完成测验。测验完成后，你可以根据结果，回到相应章节，有针对性地进行复习。</p>
<h3 id="关于栈、队列和递归的几个必知必会的代码实现"><a href="#关于栈、队列和递归的几个必知必会的代码实现" class="headerlink" title="关于栈、队列和递归的几个必知必会的代码实现"></a>关于栈、队列和递归的几个必知必会的代码实现</h3><p><strong>栈</strong></p>
<p>用数组实现一个顺序栈</p>
<p>用链表实现一个链式栈</p>
<p>编程模拟实现一个浏览器的前进、后退功能</p>
<p><strong>队列</strong></p>
<p>用数组实现一个顺序队列</p>
<p>用链表实现一个链式队列</p>
<p>实现一个循环队列</p>
<p><strong>递归</strong></p>
<p>编程实现斐波那契数列求值 f(n)=f(n-1)+f(n-2)</p>
<p>编程实现求阶乘 n!</p>
<p>编程实现一组数据集合的全排列</p>
<h3 id="对应的-LeetCode-练习题（-Smallfly-整理）-1"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）-1" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><ul>
<li><strong>栈</strong></li>
</ul>
<p>Valid Parentheses（有效的括号）</p>
<p>英文版：<a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-parentheses/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/</a></p>
<p>Longest Valid Parentheses（最长有效的括号）</p>
<p>英文版：<a href="https://leetcode.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-valid-parentheses/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-valid-parentheses/</a></p>
<p>Evaluate Reverse Polish Notatio（逆波兰表达式求值）</p>
<p>英文版：<a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">https://leetcode.com/problems/evaluate-reverse-polish-notation/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/</a></p>
<ul>
<li><strong>队列</strong></li>
</ul>
<p>Design Circular Deque（设计一个双端队列）</p>
<p>英文版：<a href="https://leetcode.com/problems/design-circular-deque/" target="_blank" rel="noopener">https://leetcode.com/problems/design-circular-deque/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/design-circular-deque/</a></p>
<p>Sliding Window Maximum（滑动窗口最大值）</p>
<p>英文版：<a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">https://leetcode.com/problems/sliding-window-maximum/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p>
<ul>
<li><strong>递归</strong></li>
</ul>
<p>Climbing Stairs（爬楼梯）</p>
<p>英文版：<a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">https://leetcode.com/problems/climbing-stairs/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs/</a></p>
<p>昨天的第一篇，是关于数组和链表的，如果你错过了，点击文末的“上一篇”，即可进入测试。</p>
<p>祝你取得好成绩！明天见！</p>
<h2 id="春节7天练-Day-3：排序和二分查找"><a href="#春节7天练-Day-3：排序和二分查找" class="headerlink" title="春节7天练 | Day 3：排序和二分查找"></a>春节7天练 | Day 3：排序和二分查找</h2><p>王争 2019-02-06</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d35skyj30vq0hsq51.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>你好，我是王争。初三好！</p>
<p>为了帮你巩固所学，真正掌握数据结构和算法，我整理了数据结构和算法中，必知必会的 30 个代码实现，分 7 天发布出来，供你复习巩固所用。今天是第三篇。</p>
<p>和昨天一样，你可以花一点时间，来完成测验。测验完成后，你可以根据结果，回到相应章节，有针对性地进行复习。</p>
<p>前两天的内容，是关于数组和链表、排序和二分查找的。如果你错过了，点击文末的“上一篇”，即可进入测试。</p>
<h3 id="关于排序和二分查找的几个必知必会的代码实现"><a href="#关于排序和二分查找的几个必知必会的代码实现" class="headerlink" title="关于排序和二分查找的几个必知必会的代码实现"></a>关于排序和二分查找的几个必知必会的代码实现</h3><p><strong>排序</strong></p>
<p>实现归并排序、快速排序、插入排序、冒泡排序、选择排序</p>
<p>编程实现 O(n) 时间复杂度内找到一组数据的第 K 大元素</p>
<p><strong>二分查找</strong></p>
<p>实现一个有序数组的二分查找算法</p>
<p>实现模糊二分查找算法（比如大于等于给定值的第一个元素）</p>
<h3 id="对应的-LeetCode-练习题（-Smallfly-整理）-2"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）-2" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><p>Sqrt(x) （x 的平方根）</p>
<p>英文版：<a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">https://leetcode.com/problems/sqrtx/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx/</a></p>
<p>做完题目之后，你可以点击“请朋友读”，把测试题分享给你的朋友，说不定就帮他解决了一个难题。</p>
<p>祝你取得好成绩！明天见！</p>
<h2 id="春节7天练-Day-4：散列表和字符串"><a href="#春节7天练-Day-4：散列表和字符串" class="headerlink" title="春节7天练 | Day 4：散列表和字符串"></a>春节7天练 | Day 4：散列表和字符串</h2><p>王争 2019-02-08</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp7whpp32aj30vq0hsgpf.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>你好，我是王争。初四好！</p>
<p>为了帮你巩固所学，真正掌握数据结构和算法，我整理了数据结构和算法中，必知必会的 30 个代码实现，分 7 天发布出来，供你复习巩固所用。今天是第四篇。</p>
<p>和昨天一样，你可以花一点时间，来完成测验。测验完成后，你可以根据结果，回到相应章节，有针对性地进行复习。</p>
<p>前几天的内容。如果你错过了，点击文末的“上一篇”，即可进入测试。</p>
<h3 id="关于散列表和字符串的-4-个必知必会的代码实现"><a href="#关于散列表和字符串的-4-个必知必会的代码实现" class="headerlink" title="关于散列表和字符串的 4 个必知必会的代码实现"></a>关于散列表和字符串的 4 个必知必会的代码实现</h3><p><strong>散列表</strong></p>
<p>实现一个基于链表法解决冲突问题的散列表</p>
<p>实现一个 LRU 缓存淘汰算法</p>
<p><strong>字符串</strong></p>
<p>实现一个字符集，只包含 a～z 这 26 个英文字母的 Trie 树</p>
<p>实现朴素的字符串匹配算法</p>
<h3 id="对应的-LeetCode-练习题（-Smallfly-整理）-3"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）-3" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><p><strong>字符串</strong></p>
<p>Reverse String （反转字符串）</p>
<p>英文版：<a href="https://leetcode.com/problems/reverse-string/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-string/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string/</a></p>
<p>Reverse Words in a String（翻转字符串里的单词）</p>
<p>英文版：<a href="https://leetcode.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-words-in-a-string/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></p>
<p>String to Integer (atoi)（字符串转换整数 (atoi)）</p>
<p>英文版：<a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode.com/problems/string-to-integer-atoi/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p>
<p>做完题目之后，你可以点击“请朋友读”，把测试题分享给你的朋友，说不定就帮他解决了一个难题。</p>
<p>祝你取得好成绩！明天见！</p>
<h2 id="春节7天练-Day-5：二叉树和堆"><a href="#春节7天练-Day-5：二叉树和堆" class="headerlink" title="春节7天练 | Day 5：二叉树和堆"></a>春节7天练 | Day 5：二叉树和堆</h2><p>王争 2019-02-09</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84ddviq9j30vq0hs0uu.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>你好，我是王争。春节假期进入尾声了。你现在是否已经准备返回工作岗位了呢？今天更新的是测试题的第五篇，我们继续来复习。</p>
<h3 id="关于二叉树和堆的-7-个必知必会的代码实现"><a href="#关于二叉树和堆的-7-个必知必会的代码实现" class="headerlink" title="关于二叉树和堆的 7 个必知必会的代码实现"></a>关于二叉树和堆的 7 个必知必会的代码实现</h3><p><strong>二叉树</strong></p>
<p>实现一个二叉查找树，并且支持插入、删除、查找操作</p>
<p>实现查找二叉查找树中某个节点的后继、前驱节点</p>
<p>实现二叉树前、中、后序以及按层遍历</p>
<p><strong>堆</strong></p>
<p>实现一个小顶堆、大顶堆、优先级队列</p>
<p>实现堆排序</p>
<p>利用优先级队列合并 K 个有序数组</p>
<p>求一组动态数据集合的最大 Top K</p>
<h3 id="对应的-LeetCode-练习题（-Smallfly-整理）-4"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）-4" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><p>Invert Binary Tree（翻转二叉树）</p>
<p>英文版：<a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/invert-binary-tree/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>
<p>Maximum Depth of Binary Tree（二叉树的最大深度）</p>
<p>英文版：<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p>
<p>Validate Binary Search Tree（验证二叉查找树）</p>
<p>英文版：<a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/validate-binary-search-tree/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/validate-binary-search-tree/</a></p>
<p>Path Sum（路径总和）</p>
<p>英文版：<a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-sum/</a></p>
<p>做完题目之后，你可以点击“请朋友读”，把测试题分享给你的朋友。</p>
<p>祝你取得好成绩！明天见！</p>
<h2 id="春节7天练-Day-6：图"><a href="#春节7天练-Day-6：图" class="headerlink" title="春节7天练 | Day 6：图"></a>春节7天练 | Day 6：图</h2><p>王争 2019-02-10</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84dbzsjgj30vq0hs40m.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>你好，我是王争。初六好！</p>
<p>为了帮你巩固所学，真正掌握数据结构和算法，我整理了数据结构和算法中，必知必会的 30 个代码实现，分 7 天发布出来，供你复习巩固所用。今天是第六篇。</p>
<p>和之前一样，你可以花一点时间，来手写这些必知必会的代码。写完之后，你可以根据结果，回到相应章节，有针对性地进行复习。做到这些，相信你会有不一样的收获。</p>
<h3 id="关于图的几个必知必会的代码实现"><a href="#关于图的几个必知必会的代码实现" class="headerlink" title="关于图的几个必知必会的代码实现"></a>关于图的几个必知必会的代码实现</h3><p><strong>图</strong></p>
<p>实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法</p>
<p>实现图的深度优先搜索、广度优先搜索</p>
<p>实现 Dijkstra 算法、A* 算法</p>
<p>实现拓扑排序的 Kahn 算法、DFS 算法</p>
<h3 id="对应的-LeetCode-练习题（-Smallfly-整理）-5"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）-5" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><p>Number of Islands（岛屿的个数）</p>
<p>英文版：<a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-islands/description/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/number-of-islands/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands/description/</a></p>
<p>Valid Sudoku（有效的数独）</p>
<p>英文版：<a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-sudoku/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-sudoku/</a></p>
<p>做完题目之后，你可以点击“请朋友读”，把测试题分享给你的朋友，说不定就帮他解决了一个难题。</p>
<p>祝你取得好成绩！明天见！</p>
<h2 id="春节7天练-Day-7：贪心、分治、回溯和动态规划"><a href="#春节7天练-Day-7：贪心、分治、回溯和动态规划" class="headerlink" title="春节7天练 | Day 7：贪心、分治、回溯和动态规划"></a>春节7天练 | Day 7：贪心、分治、回溯和动态规划</h2><p>王争 2019-02-10</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp7waufhjqj30vq0hsgpe.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>你好，我是王争。今天是节后的第一个工作日，也是我们“春节七天练”的最后一篇。</p>
<h3 id="几种算法思想必知必会的代码实现"><a href="#几种算法思想必知必会的代码实现" class="headerlink" title="几种算法思想必知必会的代码实现"></a>几种算法思想必知必会的代码实现</h3><p><strong>回溯</strong></p>
<p>利用回溯算法求解八皇后问题</p>
<p>利用回溯算法求解 0-1 背包问题</p>
<p><strong>分治</strong></p>
<p>利用分治算法求一组数据的逆序对个数</p>
<p><strong>动态规划</strong></p>
<p>0-1 背包问题</p>
<p>最小路径和（详细可看 @Smallfly 整理的 Minimum Path Sum）</p>
<p>编程实现莱文斯坦最短编辑距离</p>
<p>编程实现查找两个字符串的最长公共子序列</p>
<p>编程实现一个数据序列的最长递增子序列</p>
<h3 id="对应的-LeetCode-练习题（-Smallfly-整理）-6"><a href="#对应的-LeetCode-练习题（-Smallfly-整理）-6" class="headerlink" title="对应的 LeetCode 练习题（@Smallfly 整理）"></a>对应的 LeetCode 练习题（@Smallfly 整理）</h3><p>Regular Expression Matching（正则表达式匹配）</p>
<p>英文版：<a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/</a></p>
<p>Minimum Path Sum（最小路径和）</p>
<p>英文版：<a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-path-sum/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-path-sum/</a></p>
<p>Coin Change （零钱兑换）</p>
<p>英文版：<a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode.com/problems/coin-change/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change/</a></p>
<p>Best Time to Buy and Sell Stock（买卖股票的最佳时机）</p>
<p>英文版：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>
<p>Maximum Product Subarray（乘积最大子序列）</p>
<p>英文版：<a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-product-subarray/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p>
<p>Triangle（三角形最小路径和）</p>
<p>英文版：<a href="https://leetcode.com/problems/triangle/" target="_blank" rel="noopener">https://leetcode.com/problems/triangle/</a></p>
<p>中文版：<a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/triangle/</a></p>
<p>到此为止，七天的练习就结束了。这些题目都是我精选出来的，是基础数据结构和算法中最核心的内容。建议你一定要全部手写练习。如果一遍搞不定，你可以结合前面的章节，多看几遍，反复练习，直到能够全部搞定为止。</p>
<p>学习数据结构和算法，最好的方法就是练习和实践。我相信这在任何知识的学习过程中都适用。</p>
<p>最后，祝你工作顺利！学业进步！</p>
<h2 id="【用户故事】-Jerry银银：这一年我的脑海里只有算法"><a href="#【用户故事】-Jerry银银：这一年我的脑海里只有算法" class="headerlink" title="【用户故事】 | Jerry银银：这一年我的脑海里只有算法"></a>【用户故事】 | Jerry银银：这一年我的脑海里只有算法</h2><p>Jerry银银 2019-02-13</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d54x8uj30vq0hs0vk.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>比尔·盖茨曾说过：“如果你自以为是一个很好的程序员，请去读读 Donald E. Knuth 的《计算机程序设计艺术》吧……要是你真把它读下来了，就毫无疑问可以给我递简历了。”虽然比尔·盖茨推荐的是《计算机程序设计艺术》这本书，但是本质却折射出了算法的重要性。</p>
<p>大家好，我是 Jerry 银银，购买过算法专栏的同学应该时不时会看到我的留言！目前我是一名 Android 应用开发工程师，主要从事移动互联网教育软件的研发，坐标上海。</p>
<h3 id="我为何要学算法？"><a href="#我为何要学算法？" class="headerlink" title="我为何要学算法？"></a>我为何要学算法？</h3><p>细细想来，从毕业到现在，7 年多的时间，我的脑海里一直没有停止过思考这样一个问题：<strong>技术人究竟能够走多远，技术人的路究竟该如何走下去</strong>？相信很多技术人应该有同样的感受，因为技术的更新迭代实在是太快了，但是我心里明白：<strong>我得为长远做打算，否则，就算换公司、换工作，可能本质也不会有什么改变</strong>。</p>
<p>但是，我其实不太清楚自己到底应该往什么地方努力。于是，我翻阅了好多书籍，搜寻 IT 领域各种牛人的观点。多方比较之后，我终于决定，从基础开始，从计算机领域最基础、最重要的一门课开始。毫无疑问，这门课就是数据结构和算法。</p>
<h3 id="我是如何遇见极客时间的？"><a href="#我是如何遇见极客时间的？" class="headerlink" title="我是如何遇见极客时间的？"></a>我是如何遇见极客时间的？</h3><p>既然找到了方向，那就开始吧。可是问题来了，从哪儿开始呢？大方向虽然有了，可是具体的实现细节还是得慢慢摸索。大学没怎么学，工作这么多年也没有刻意练习，起初我还真不知道从哪儿开始，只是买了本书，慢慢地啃，也找了一些简单的题目开始做。有过自学经历的同学，应该有同感吧？刚开始连单链表翻转这样简单的题都要折腾半天，真心觉得“痛苦”。</p>
<p>之前我在极客时间上订阅过“Java 核心技术 36 讲”，体会到了专栏和书本的不同。极客时间的专栏作者都是有着丰富的一线开发经验，能很好地把知识和实战结合在一起的大牛。这些课听起来非常爽。估计你应该经常跟我一样感叹：“哦！原来这些知识还可以这么使用！”当时我就在想，极客时间啥时候有一门算法课就好了。</p>
<p>说来真是巧，没多久，极客时间就推出了“数据结构与算法之美”。我试读了《为什么要学习数据结构和算法》和《数组：为什么很多编程语言中数组都从 0 开始编号？》这两篇之后，立即购买了。</p>
<p>到现在，专栏学完了，但是我依然记得，王争老师在《为什么要学习数据结构和算法》这篇文章里面提到的三句话，因为这每一句话都刺痛了我的小心脏！</p>
<p>第一句：业务开发工程师，你真的愿意做一辈子 CRUD Boy 吗？</p>
<p>第二句：基础架构研发工程师，写出达到开源水平的框架才是你的目标！</p>
<p>第三句：对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！</p>
<h3 id="我每天是怎么学专栏的？"><a href="#我每天是怎么学专栏的？" class="headerlink" title="我每天是怎么学专栏的？"></a>我每天是怎么学专栏的？</h3><p>于是，每天早上醒来，我的第一件事就是听专栏！专栏在每周的一、三、五更新，每周的这三天早上，我会听更新的文章。其它时间，我就听老的文章，当作复习。</p>
<p>听的过程，我一般会分这么几种情况。</p>
<p><strong>第一种情况，更新的内容是我之前就已经学过的，基本已经掌握了的</strong>。这种情况下，听起来相对轻松点，基本上听一遍就够了。起床之后，再做一下老师给的思考题。这种情况在专栏的基础部分出现得比较多，像数组、链表、栈、队列、哈希表这些章节，我基本上都是这么过来的。</p>
<p><strong>第二种情况，更新的内容是我学过的，但是还不太精通的</strong>。这种情况下，王争老师讲的内容都会将我的认知往前“推进”一步。顺利的话，我会在上班之前就搞懂今天更新的内容。这种情况是曾经没有接触过的内容，但是整体来说不难的理解的，比如跳表、递归等。</p>
<p><strong>还有一种情况，就是听一遍不够，听完再看一遍也不行，上午上班之前也搞不定的</strong>。不过，我也不会急躁。我心里知道，我可能需要换换脑子，说不定，在上午工作期间，灵感会突然冒出来。这种情况一般出现在红黑树、字符串查找算法、动态规划这些章节。</p>
<p>到了中午休息时间，我会一个人在公司楼下转一圈，同样，还是听专栏、看专栏。</p>
<p>如果今天的文章，早上已经搞定了，我会重新看下其他同学的留言，看看其他同学是如何思考文章的课后思考题的，还有就是，我会看看其他同学学习过程中，会有哪些疑问，这些疑问自己曾经是否遇到过，现在是否已经完全解决了。</p>
<p>如果今天的文章，早上没有彻底搞懂，这种情况下，我会极力利用中午的时间去思考。</p>
<p>晚上的时间通常无法确定，我有时候会加班到很晚，回到家，再去啃算法，效率也不高。所以，我一般会在晚上“看”算法。为什么我会用双引号呢？是因为我真得只是“看”，目的就是加深印象。</p>
<p>以上基本是我工作日学专栏的“套路”。</p>
<p>等到了周末或者其它节假日，就是“打攻坚战”的时候了。估计很多上班族和我一样，只有周末才有大量集中思考的时间。这时候，我一般会通过做题来反向推动自己的算法学习。</p>
<p>像红黑树、Trie 树、递归、动态规划这些内容，我都是在周末和节假日搞懂的。虽然到现在对其中一些知识还不能达到游刃有余的地步，但是对一般的问题，大体上我都知道该如何抽象、如何拆解了。</p>
<p><img src="https://static001.geekbang.org/resource/image/0c/72/0c441ee9376e974f5112eab4dd7b2672.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d9qp68j315e0u0e81.jpg" alt="img"></p>
<p>我在学习算法时记的笔记</p>
<h3 id="通过学习专栏，我有什么不一样的收获？"><a href="#通过学习专栏，我有什么不一样的收获？" class="headerlink" title="通过学习专栏，我有什么不一样的收获？"></a>通过学习专栏，我有什么不一样的收获？</h3><p><strong>首先，专栏学习拓宽了我的知识面。</strong>例如，很多书本不讲的跳表，王争老师用了一篇文章来讲解。犹记得当我看完跳表时，心想，这么简单、易懂、高效的数据结构，为什么很多书籍都没有呢？这个专栏真的买值了！</p>
<p><strong>其次，专栏的理论和实践结合很强。</strong>书籍是通用性很强的教材，一般很少会涉及软件系统是如何使用具体的数据结构和算法的。在专栏中，老师把对应的知识和实践相互结合，听起来特别过瘾！比如堆这种数据结构，理解起来不难，但是要用好它，还得下点功夫，经过老师一讲解，搭配音频，我的理解也变得更加深入了。</p>
<p><strong>最后，专栏留言这个功能真的太好了，为自学带来了诸多便利，也让我获得了很多正向反馈。</strong>很多时候，经过相当长的一段时间思考，还是不能打通任督二脉，其实后来回想，当时就差那一层窗户纸了。于是，我在文末留下了自己的疑问，结果王争老师轻描淡写一句话我就明白了。</p>
<p>留言功能还有个非常大的好处。如果你用心学习，用心思考，用心留言，你的留言很大概率会被同伴点赞，很多时候还能被置顶。这本身就是一种正向反馈，也会更加促进自己的学习动力。还有一种更爽的体验，突然有一天早上，我照例醒来听专栏，突然听到了自己的名字。这个专栏 4 万多人订阅，老师居然记得我！可见王争老师真的认真看了每一条留言。</p>
<p>最后，我总结下自己学这个专栏的收获。尽管很多，但是我想用三句话来概括。</p>
<p>第一，写代码的时候，我会很自然地从时间和空间角度去衡量代码的优劣，时间、空间意识被加强了很多。</p>
<p>第二，学习算法的过程，有很多的“痛苦”，也正是因为这些“痛苦”，我学到了很多知识以外的东西。</p>
<p>第三，过程可能比知识更重要。要从过程中体会成长和精进的乐趣，而知识是附加产品！</p>
<p>专栏虽然结束，但是学习并没有结束。同学们，我们开头见！</p>
<h2 id="【用户故事-】-zixuan：站在思维的高处，才有足够的视野和能力欣赏“美”"><a href="#【用户故事-】-zixuan：站在思维的高处，才有足够的视野和能力欣赏“美”" class="headerlink" title="【用户故事 】| zixuan：站在思维的高处，才有足够的视野和能力欣赏“美”"></a>【用户故事 】| zixuan：站在思维的高处，才有足够的视野和能力欣赏“美”</h2><p>zixuan 2019-02-15</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d61adij30vq0hstcy.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p></p>
<p>00:12</p>
<p><a href="javascript:;" target="_blank" rel="noopener">1.25x<em></em></a></p>
<p>讲述：修阳 大小：11.53M 时长：12:35</p>
<p>大家好，我是 zixuan，在一家国内大型互联网公司做后端开发，坐标深圳，工作 5 年多了。今天和大家分享一下，我学习专栏的一些心得体会。</p>
<p>随着年龄的增长，我经历了不少业务、技术平台、中间件等多种环境和编程工具的迭代变更。与此同时，我越来越意识到，要做一名优秀的程序员，或者说，能够抵御年龄增长并且增值的程序员，有两样内功是必须持续积累的，那就是<strong>软件工程经验方法</strong>和<strong>算法应用能力</strong>。</p>
<p>通俗地讲，就是不论在什么系统或业务环境下、用什么编程工具，都能写出高质量、可维护、接口化代码的能力，以及分解并给出一个实际问题有效解决方案的能力。</p>
<h3 id="我为什么会订阅这个专栏？"><a href="#我为什么会订阅这个专栏？" class="headerlink" title="我为什么会订阅这个专栏？"></a>我为什么会订阅这个专栏？</h3><p>这也是为什么我在极客时间上看到王争老师的“数据结构与算法之美”的开篇词之后，果断地加入学习行列。同时，我也抱有以下两点期望。</p>
<p>第一，这个专栏是从工程应用，也就是解决实际问题的角度出发来讲算法的，原理和实践相辅相成，现学现用，并且重视思考过程。从我个人经验来看，这的确是比较科学的学习方法。我相信很多人和我一样，以前在学校里都学过算法，不过一旦不碰书了，又没有了应用场景后，很快就把学过的东西丢了，重新拾起来非常困难。</p>
<p>第二，从专栏的标题看出，王争老师试图带我们感受算法的“美”，那必将要先引导我们站在思维的高处，这样才有足够的视野和能力去欣赏这种“美”。我很好奇他会怎么做，也好奇我能否真正地改变以前的认知，切身地感受到“美”。</p>
<h3 id="我是如何学习这个专栏的？"><a href="#我是如何学习这个专栏的？" class="headerlink" title="我是如何学习这个专栏的？"></a>我是如何学习这个专栏的？</h3><p>就这样，同时带着笃定和疑问，我上路了。经过几个月的认真学习，“数据结构与算法之美”成了我在极客时间打开次数最多，花费时间最多，完成度也最高的一门课。<strong>尽管如此，我觉得今后我很可能还会再二刷、多刷**</strong>这门课<strong>**，把它作为一个深入学习的索引入口。</strong> 接下来，我就从几个方面，跟你分享下，这半年我学习这个专栏的一些感受和收获。</p>
<h3 id="1-原理和实用并重：从实践中总结，应用到实践中去"><a href="#1-原理和实用并重：从实践中总结，应用到实践中去" class="headerlink" title="1. 原理和实用并重：从实践中总结，应用到实践中去"></a>1. 原理和实用并重：从实践中总结，应用到实践中去</h3><p>学习的最终目的是为了解决实际问题，专栏里讲的很多方法甚至代码，都能够直接应用到大型项目中去，而不仅仅是简单的原理示例。</p>
<p>比如王争老师在讲散列表的时候，讲了实现一个工业级强度的散列表有哪些需要注意的点。基本上面面俱到，我在很多标准库里都找到了印证。再比如，老师讲的 LRU Cache、Bloom Filter、范围索引上的二分查找等等，也基本和我之前阅读 LevelDB 源代码时，看到的实现细节如出一辙，无非是编程语言的差别。</p>
<p>所以，看这几部分的时候，我觉得十分惊喜，因为我经历过相关的实际应用场景。反过来，专栏这种原理和实用并重的风格，也能帮助我今后在阅读开源代码时提升效率、增进理解。</p>
<p>另外，我觉察到，文章的组织结构，应该也是老师试图传达给我们的“他自己的学习方法”：从开篇介绍一个经典的实际问题开始（需求），到一步步思考引导（分析），再到正式引出相关的数据结构和算法（有效解决方案），再将其应用于开篇问题的解决（实现、测试），最后提出一个课后思考题（泛化、抽象、交流、提升）。</p>
<p>这个形式其实和解决实际工程问题的过程非常类似。我想，大部分工程师就是在一个个这样的过程中不断积累和提升自己的，所以我觉得这个专栏，不论是内容还是形式真的都很赞。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d1lnl5j30vq0frq5i.jpg" alt="img"></p>
<h3 id="2-学习新知识的角度：体系、全面、严谨、精炼，可视化配图易于理解"><a href="#2-学习新知识的角度：体系、全面、严谨、精炼，可视化配图易于理解" class="headerlink" title="2. 学习新知识的角度：体系、全面、严谨、精炼，可视化配图易于理解"></a>2. 学习新知识的角度：体系、全面、严谨、精炼，可视化配图易于理解</h3><p>“全面”并不是指所有细节面面俱到。事实上，由于算法这门学科本身庞大的体量，这类专栏一般只能看作一个丰富的综述目录，或者深入学习的入口。尽管如此，王争老师依然用简洁精炼的语言 Cover 到了几乎所有最主要的数据结构和算法，以及它们背后的本质思想、原理和应用场景，知识体系结构全面完整并自成一体。</p>
<p>我发现只要能紧跟老师的思路，把每一节的内容理解透彻，到了语言实现部分，往往变成了一种自然的总结描述，所以代码本身并不是重点，重点是背后的思路。</p>
<p>例如，KMP 单模式串匹配和 AC 自动机多模式串匹配算法是我的知识盲区。以前读过几次 KMP 的代码，都没完全搞懂，于是就放弃了。至于 AC 自动机，惭愧地说，我压根儿就没怎么听说过。</p>
<p>但是，在专栏里，王争老师从 BruteForce 方法讲起，经过系统的优化思路铺垫，通俗的举例，再结合恰到好处的配图，最后给出精简的代码。我跟随着老师一路坚持下来，当我看到第二遍时突然就豁然开朗了。而当我真正理解了 AC 自动机的构建和工作原理之后，在某一瞬间，我的内心的确生出了一种美的感觉（或者更多的是“妙”吧？）。</p>
<p>AC 自动机构建的代码，让我不自觉地想到“编织”这个词。之前还觉得凌乱的、四处喷洒的指针，在这里一下子变成了一张有意义的网，编织的过程和成品都体现出了算法的巧妙。这类联想无疑加深了我对这类算法的理解，也许这也意味着，我可以把它正式加入到自己的算法工具箱里了。</p>
<p>另外一个例子是动态规划。以前应用 DP 的时候，我常常比较盲目，不知道怎么确定状态的表示，甚至需要几维的状态都不清楚，可以说是在瞎猜碰运气。经过老师从原理到实例的系统讲解后，我现在明白，原来 DP 本质上就是在压缩重复子问题，状态的定义可以通过最直接的回溯搜索来启发确定。明白这些之后，动态规划也被我轻松拿下了。</p>
<h3 id="3-已有知识加深的角度：促进思考，连点成线"><a href="#3-已有知识加深的角度：促进思考，连点成线" class="headerlink" title="3. 已有知识加深的角度：促进思考，连点成线"></a>3. 已有知识加深的角度：促进思考，连点成线</h3><p>之前看目录的时候，我发现专栏里包含了不少我已经知道的知识。但真正学习了之后，我发现，以前头脑中的不少概念知识点，是相对独立存在的，基本上一个点就对应固定的那几个场景，而在专栏里，王争老师比较注重概念之间的相互关联。对于这些知识，经过王争老师的讲解，基本可以达到交叉强化理解，甚至温故知新的效果。</p>
<p>比如老师会问你，在链表上怎么做二分查找？哈希和链表为什么经常在一起出现？这些问题我之前很少会考虑到，但是当我看到的时候，却启发出很多新的要点和场景（比如 SkipList、LRUCache）。</p>
<p>更重要的是，跟着专栏学习一段时间之后，我脑中原本的一些旧概念，也开始自发地建立起新的连接，连点成线，最后产生了一些我之前从未注意到的想法。</p>
<p>举个感触最深的例子。在跟随专栏做了大量递归状态跟进推演，以及递归树分析后，我现在深刻地认识到，递归这种编程技巧背后，其实是树和堆栈这两种看似关联不大的数据结构。为什么这么说呢？</p>
<p>堆栈和树在某个层面上，其实有着强烈的对应关系。我刚接触递归的时候，和大多数初学者一样，脑子很容易跟着机器执行的顺序往深里绕，就像 Debug 一个很深的函数调用链一样，每遇到一个函数就 step into，也就是递归函数展开 -&gt; 下一层 -&gt; 递归函数展开 -&gt; 下一层 -&gt;…，结果就是只有“递”，没有“归”，大脑连一次完整调用的一半都跑不完（或者跑完一次很辛苦），自然就会觉得无法分析。如下图，每个圈代表在某一层执行的递归函数，向下的箭头代表调用并进入下一层。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d5f8lfj30vq0kognm.jpg" alt="img"></p>
<p>我初学递归时遇到的问题：有去无回，陷得太深</p>
<p>随着我处理了越来越多的递归，我慢慢意识到，为什么人的思考一定要 follow 机器的执行呢？在递归函数体中，我完全可以不用每遇到递归调用都展开并进入下一层（step into），而是可以直接假定下一层调用能够正确返回，然后我该干嘛就继续干嘛（step over），这样的话，我只需要保证最深一层的逻辑，也就是递归的终止条件正确即可。</p>
<p>原因也很简单，不管在哪一层，都是在执行递归函数这同一份代码，不同的层只有一些状态数据不同而已，所以我只需要保证递归函数代码逻辑的正确性，就确保了运行时任意一层的结果正确性。像这样说服自己可以随时 step over 后，我的大脑终于有“递”也有“归”了，后续事务也就能够推动了。</p>
<p><img src="https://static001.geekbang.org/resource/image/5d/f8/5d42370f6823b1ed97d5d86d773ac0f8.jpg" alt="img"></p>
<p>有一定经验后我如何思考递归：有去有回，自由把握</p>
<p>最近在学习这门课程的过程中，我进一步认识到，其实上面两个理解递归的方式，分别对应递归树的深度遍历和广度遍历。尽管机器只能按照深度优先的方式执行递归代码，但人写递归代码的时候更适合用广度的思考方式。当我在实现一个递归函数的时候，其实就是在确定这棵树的整体形状：什么时候终止，什么条件下生出子树，也就是说我实际上是在编程实现一棵树。</p>
<p>那递归树和堆栈又有什么关系呢？递归树中从根节点到树中任意节点的路径，都对应着某个时刻的函数调用链组成的堆栈。递归越深的节点越靠近栈顶，也越早返回。因而我们可以说，递归的背后是一棵树，递归的执行过程，就是在这棵树上做深度遍历的过程，每次进入下一层（“递”）就是压栈，每次退出当前层（“归”）就是出栈。所有的入栈、出栈形成的脉络就组成了递归树的形态。递归树是静态逻辑背景，而当前活跃堆栈是当前动态运行前景。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84dcjj0ej30vq0fywg7.jpg" alt="img"></p>
<p>学完专栏后我怎么看待递归：胸有成“树”，化动为静</p>
<p>这样理解之后，编写或阅读递归代码的时候，我真的能够站得更高，看得更全面，也更不容易掉入一些细节陷阱里去了。</p>
<p>说到这里，我想起之前在不同时间做过的两道题，一道是计算某个长度为 n 的入栈序列可以有多少种出栈序列，另一道是计算包含 n 个节点的二叉树有多少种形状。我惊讶地发现，这两个量竟然是相等的（其实就是卡特兰数）。当时我并不理解为什么栈和树会存在这种关联，现在通过类似递归树的思路我觉得我能够理解了，那就是每种二叉树形状的中序遍历都能够对应上一种出栈顺序。</p>
<p>类似这样“旧知识新理解”还有很多，尽管专栏里并没有直接提到，但是这都是我跟随专栏，坚持边学边思考，逐步感受和收获的。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>基于以上谈的几点收获和感受，我再总结下我认为比较有用的、学习这个专栏的方法。</p>
<p><strong>1. 紧跟老师思路走，尽量理解每一句话、每一幅配图，亲手推演每一个例子。</strong></p>
<p>王争老师语言精炼。有些文字段落虽短，但背后的信息量却很大。为了方便我们理解，老师用了大量的例子和配图来讲解。即便是非常复杂、枯燥的理论知识，我们理解起来也不会太吃力。</p>
<p>当然有些地方确实有点儿难，这时我们可以退而求其次，“先保接口，再求实现”。例如，红黑树保持平衡的具体策略实现，我跟不下来，就暂时跳过去了，但是我只要知道，它是一种动态数据的高效平衡树，就不妨碍我先使用这个工具，之后再慢慢理解。</p>
<p><strong>2. 在学的过程中回顾和刷新老知识点，并往工程实践上靠。学以致用是最高效的方法</strong>。</p>
<p><strong>3. 多思考，思考比结果重要；多交流，亲身感受和其他同学一起交流帮助很大。</strong></p>
<p>最后，感谢王争老师和极客时间，让我在这个专栏里有了不少新收获。祝王争老师事业蒸蒸日上，继续开创新品，也希望极客时间能够联合更多的大牛老师，开发出更多严谨又实用的精品课程！</p>
<h2 id="结束语-送君千里，终须一别"><a href="#结束语-送君千里，终须一别" class="headerlink" title="结束语 | 送君千里，终须一别"></a>结束语 | 送君千里，终须一别</h2><p>王争 2019-02-20</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84dfe15cj30vq0hstcw.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>专栏到今天真的要结束了。在写这篇结束语的时候，我的心情还是蛮复杂的，既有点如释重负，又有点不舍。如释重负，是因为我自己对专栏的整体质量非常满意；不舍，是因为我还想分享更多“压箱底”的东西给你。</p>
<p>专栏是在 2018 年 9 月发布的。在发布后的两三天时间里，就有 2 万多人订阅，同时也引来了很多争议。有人说，我就是随便拿个目录就来“割韭菜”。也有人说，数据结构和算法的书籍那么多，国外还有那么多动画、视频教程，为什么要来学我的专栏？</p>
<p>这些质疑我都非常理解，毕竟大部分基础学科的教材，的确是国外的更全面。实际上，在专栏构思初期，我就意识到了这一点。不夸张地讲，我几乎读过市面上所有有关数据结构和算法的书籍，所以，我也深知市面上的数据结构和算法书籍存在的问题。</p>
<p>尽管有很多书籍讲得通俗易懂，也有很多书籍全面、经典，但是大部分都偏理论，书中的例子也大多脱离真实的软件开发。这些书籍毫无疑问是有用的，但是看完书之后，很多人只是死记硬背了一些知识点而已。这样填鸭式的学习，对于锻炼思维、开拓眼界并没有太多作用。而且，从基础理论到应用实践，有一个非常大的鸿沟要跨越，这是大学教育的普遍不足之处，这也是为什么我们常常觉得大学里学过的很多知识都没用。</p>
<p>我本人是一个追求完美、极致的人，凡事都想做到最好，都想争第一。所以，就我个人而言，我也不允许自己写一个“太普通”“烂大街”的专栏。那时我就给自己立了一个 flag：我一定要写一个跟所有国内、国外经典书籍都不一样的专栏，写出一个可以长期影响一些人的专栏。</p>
<p>所以，在这个专栏写作过程中，我力争并非只是单纯地把某个知识点讲清楚，而是结合自己的理解、实践和经验来讲解。我写每篇文章的时候，几乎都是从由来讲起，做到让你知其然、知其所以然，并且列举大量的实际软件开发中的场景，给你展示如何利用数据结构和算法解决真实的问题。</p>
<p>除此之外，课后思考题我也不拿一些现成的 LeetCode 的题目来应付。这些题目都是我精心设计的、贴合具体实践、非常考验逻辑思维的问题。毫不夸张地讲，只把这些课后思考题做个解答，就可以写成一个有价值、有干货的专栏！</p>
<p>专栏到今天就要结束了。尽管有些内容稍有瑕疵，但我觉得我实现了最初给自己立下的 flag。那你又学得怎么样呢？</p>
<p>如果这是你第一次接触数据结构和算法，只是跟着学一遍，你可能不会完全理解所有的内容。关于这个专栏，我从来也不想标榜，我的专栏是易懂到地铁里听听就可以的。因为你要知道，没有难度的学习，也就没有收获。所以，作为初学者，你要想真的拿下数据结构和算法，时间允许的话，建议你再二刷、三刷。</p>
<p>如果你是有一定基础的小伙伴，希望你能够真的做到学以致用。在开发项目、阅读开源代码、理解中间件架构设计方面，多结合数据结构和算法，从本质上理解原理，掌握创新的源头。</p>
<p>如果你是数据结构和算法高手，那我的专栏应该也没有让你失望吧？我个人觉得，专栏里还是有很多可以给你惊喜的地方。对于你来说，哪怕只学到了一个之前没有接触的知识点，我觉得其实已经值得了。</p>
<p>送君千里终须一别。数据结构和算法的学习，我暂时只能陪你到这里了。感谢你订阅我的专栏，感谢这 5 个月的同行，真心希望我的专栏能对你有所帮助。</p>
<p>我知道，很多小伙伴都是“潜水党”，喜欢默默地学习，在专栏要结束的今天，我希望能听到你的声音，希望听听你学习这个专栏的感受和收获。最后，再次感谢！</p>
<p><a href="http://bbn7rz69sba2z1ns.mikecrm.com/vphthhO" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d2sa48j30vq0m9q8x.jpg" alt="img"></a></p>
<h2 id="第2季回归-这一次，我们一起拿下设计模式！"><a href="#第2季回归-这一次，我们一起拿下设计模式！" class="headerlink" title="第2季回归 | 这一次，我们一起拿下设计模式！"></a>第2季回归 | 这一次，我们一起拿下设计模式！</h2><p>王争 2019-11-04</p>
<p><img src="https://static001.geekbang.org/resource/image/26/89/26846808b35a081f985418258200b489.jpg" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p>你好，我是王争。“数据结构与算法之美”在今年 2 月底全部更新完毕。时隔 8 个月，我又为你带来了一个新的专栏“设计模式之美”。如果说“数据结构与算法之美”是教你如何写出高效的代码，那“设计模式之美”就是教你如何写出高质量的代码。</p>
<p>在设计“设计模式之美”专栏的时候，我仍然延续“数据结构与算法之美”的讲述方式。在专栏的整体设计上，我希望尽量还原一对一、手把手 code review 的场景，通过 100 篇正文和 10 篇不定期加餐，200 多个真实的项目实战代码案例剖析，100 多个有深度的课堂讨论、头脑风暴，来为你交付这个“设计模式之美”专栏。</p>
<p>我希望通过这个专栏，一次性把跟编写高质量代码相关的所有知识，都系统、全面地讲清楚，一次性给你讲透彻。让你看完这个专栏，就能搞清楚所有跟写高质量代码相关的知识点。</p>
<p>专栏共 100 期正文和 10 期不定期加餐，分为 5 个模块。下面是专栏的目录：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d8z52rj30ku5aae82.jpg" alt="img"></p>
<p>为了感谢老同学，我为你准备了一个专属福利：</p>
<p>11 月 4 日，专栏上新时，我会送你一张 30 元专属优惠券，可与限时优惠同享，有效期 48 小时，建议尽早使用。点击下方图片，立即免费试读新专栏。</p>
<p>一段新的征程，期待与你一起见证成长！</p>
<h2 id="打卡召集令-60-天攻克数据结构与算法"><a href="#打卡召集令-60-天攻克数据结构与算法" class="headerlink" title="打卡召集令 | 60 天攻克数据结构与算法"></a>打卡召集令 | 60 天攻克数据结构与算法</h2><p>王争 2019-11-22</p>
<p>今年 4 月，专栏更新结束之后，我在专栏发布了一篇《数据结构与算法之美》学习指导手册》，在这篇文章里，我对专栏内容重新做了一次梳理，将整个专栏拆分成四个阶段，列出了每个阶段的核心知识点、标注了每个知识点的难易程度（E-Easy，M-Medium，H-Hard），并用 1-10 分说明其重要性。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84dbphijj310s0u04qp.jpg" alt="img"></p>
<p>但是，我发现，很多同学还是没能坚持下来，久而久之对学习算法失去了信心。</p>
<p>回想起来，写专栏之初，我就立下 Flag，要做一个跟国内外经典书籍不一样、可以长期影响一些人的专栏。所以，在专栏完结 9 个月后，我想再做一些事情。</p>
<p>为了带你彻底拿下“数据结构与算法”这座大山，我发起了<strong>“60 天攻克数据结构与算法”打卡行动</strong>，一起登顶！</p>
<p>下面是我为你精心规划的学习计划表：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d807caj30ku696npd.jpg" alt="img"></p>
<p><strong>活动时间</strong>：2019.11.25-2020.1.19</p>
<p><strong>你将获得</strong>：</p>
<p>\1. 坚持 60 天，与 2000 位优秀的工程师一起，彼此激励，相互学习；</p>
<p>\2. 整个学习周期内，我会进行 2 次高质量的社群分享；</p>
<p>\3. 我会精心整理 4 张知识脑图，为你梳理每个阶段的学习重点，发布在专栏里；</p>
<p>\4. 我和极客时间准备了 20 万奖学金，给坚持下来的同学。</p>
<p><strong>活动规则</strong>：</p>
<p>在下方申请进入活动打卡群，根据课表打卡，完成学习。</p>
<p><a href="https://jinshuju.net/f/DYtafE" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84cyfiwvj30ku04mq3n.jpg" alt="img"></a></p>
<p><strong>打卡要求</strong>：</p>
<p>\1. 每个阶段持续 2 周，每周仅需打卡 3 次，即视为完成该阶段的学习。</p>
<p>2.4 个阶段（8 周）的学习，打卡总数仅需 30 次，即视为完成“60 天攻克数据结构与算法行动”。</p>
<p>\3. 为了让大家养成习惯，每日只计 1 次打卡，单日内多次打卡视为 1 次。</p>
<p><strong>进入打卡群后，完成学习还有如下奖励</strong>：</p>
<p>第一阶段（第 1-2 周）：¥15 奖励金</p>
<p>第二阶段（第 3-4 周）：¥25 奖励金</p>
<p>第三阶段（第 5-6 周）：¥35 奖励金</p>
<p>四个阶段（第 7-8 周）：¥50 奖励金</p>
<p>（注：奖励金会以无门槛优惠券形式、分阶段进行发放，发放时间为每阶段结束后的 7 个工作日内。）</p>
<p>当然，优惠券只是对你的小小奖励。坚持 60 天，与 2000 位优秀的工程师一起，互相学习，彼此激励，彻底拿下数据结构与算法，我奉陪到底。</p>
<h2 id="打卡召集令-第一阶段知识总结"><a href="#打卡召集令-第一阶段知识总结" class="headerlink" title="打卡召集令 | 第一阶段知识总结"></a>打卡召集令 | 第一阶段知识总结</h2><p>王争、阿锦 2019-12-09</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84daf8smj30u05st1kz.jpg" alt="img"></p>
<h2 id="打卡召集令-第二阶段知识总结"><a href="#打卡召集令-第二阶段知识总结" class="headerlink" title="打卡召集令 | 第二阶段知识总结"></a>打卡召集令 | 第二阶段知识总结</h2><p>王争、阿锦 2019-12-23</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84dd3xh3j30u04nchdt.jpg" alt="img"></p>
<h2 id="打卡召集令-第三阶段知识总结"><a href="#打卡召集令-第三阶段知识总结" class="headerlink" title="打卡召集令 | 第三阶段知识总结"></a>打卡召集令 | 第三阶段知识总结</h2><p>王争、阿锦 2020-01-06</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84d0pubvj30u02aykjn.jpg" alt="img"></p>
<h2 id="打卡召集令-第四阶段知识总结"><a href="#打卡召集令-第四阶段知识总结" class="headerlink" title="打卡召集令 | 第四阶段知识总结"></a>打卡召集令 | 第四阶段知识总结</h2><p>王争、阿锦 2020-01-20</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADYAAAABCAYAAACVOl3IAAAAJUlEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJilMpjs4dSM5H1AwBwSSrLZGasMwAAAABJRU5ErkJggg==" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAHUlEQVQYV2N89+7dfwYoEBQUBLPev3/PgItNSC0ADtASy+rFJtUAAAAASUVORK5CYII=" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAABCAYAAACPBr1GAAAAJ0lEQVQYV2N89+7dfwYoEBQUBLPev3/PQAkbm3mE7KBUHpd7YeYCAE50MMsBeqQ5AAAAAElFTkSuQmCC" alt="img"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAABCAYAAAAB3PQ6AAAAHUlEQVQYV2N89+7df0FBQQYQeP/+PQMxbLBiIAAAQE0Py6Kq0rkAAAAASUVORK5CYII=" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84cz41t3j30u01qou0y.jpg" alt="img"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp9afl3z98j30tc0gugxh.jpg" alt="image-20210405233140116"></p>
<p>答案：C</p>
<h6 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h6><p>基础概念，单向循环链表且带有头节点，判断为空，即循环链表只有头节点，自己指向自己，head-&gt;next = head，因此选 C。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp9aqmkt94j30w40luavt.jpg" alt="image-20210405234217284"></p>
<p>答案：D</p>
<h6 id="题目解析-7"><a href="#题目解析-7" class="headerlink" title="题目解析"></a>题目解析</h6><p>递归次数，取决于递归树，而递归树取决于轴枢的选择。树越平衡，递归次数越少。</p>
<p>而对分区的长短处理顺序，影响的是递归时对栈的使用内存，而不是递归次数。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp9arg087wj30u60jak52.jpg" alt="image-20210405234304622"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">答案：A</span><br><span class="line">题目解析</span><br><span class="line">尾递归是指，在函数返回的时候，调用自身本身，并且 return 语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</span><br><span class="line"></span><br><span class="line">以斐波那契数列为例子，普通的递归版本如下：</span><br><span class="line"></span><br><span class="line">`int fab(int n)&#123;</span><br><span class="line"></span><br><span class="line">if(n&lt;3)</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">return fab(n-1)+fab(n-2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">具有 &quot; 线性迭代过程 &quot; 特性的递归—尾递归过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int fab(int n,int b1=1,int b2=1,int c=3)&#123;</span><br><span class="line"></span><br><span class="line">if(n&lt;3)</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">else &#123;</span><br><span class="line"></span><br><span class="line">if(n==c)</span><br><span class="line"></span><br><span class="line">return b1+b2;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">return fab1(n,b2,b1+b2,c+1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; `</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以 fab(4) 为例子</span><br><span class="line"></span><br><span class="line">普通递归 fab(4)=fab(3)+fab(2)=fab(2)+fab(1)+fab(2)=3 6 次调用</span><br><span class="line"></span><br><span class="line">尾递归 fab(4,1,1,3)=fab(4,1,2,4)=1+2=3</span><br><span class="line"></span><br><span class="line">2 次调用</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp9atgzqszj30q80hm48d.jpg" alt="image-20210405234501814"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp9au42g2qj30s00h2dqa.jpg" alt="image-20210405234537327"></p>
<p>答案：A</p>
<h6 id="题目解析-8"><a href="#题目解析-8" class="headerlink" title="题目解析"></a>题目解析</h6><p>BFS 是广度优先遍历，DFS 是深度优先遍历。</p>
<p>对于一些特殊的图，比如只有一个顶点的图，其 BFS 生成树的树高和 DFS 生成树的树高相等。 一般的图，根据图的 BFS 生成树和 DFS 树的算法思想，BFS 生成树的树高比 DFS 生成树的树高小。</p>
<h2 id="菜鸟面试"><a href="#菜鸟面试" class="headerlink" title="菜鸟面试"></a>菜鸟面试</h2><p>菜鸟4.6一面面经</p>
<p>\1. 自我介绍</p>
<p>\2. 介绍一下项目中的作用以及学到了什么 3. 数据库</p>
<p>\1. 数据库中的锁</p>
<p>\2. 具体场景题，一个update 语句跟一个select语句之间的可读性问题 3. 幻读问题</p>
<p>\4. 有用过哪些数据结构</p>
<p>\1. ArrayList</p>
<p>\2. LinkedList</p>
<p>\3. 红黑树的查找效率，为什么数据库索引不使用红黑树 4. 为什么HashMap不使用B+树</p>
<p>\5. HashMap查找时间复杂度</p>
<p>\5. 计算机网络</p>
<p>\1. 有三十个http请求能不能一次连接发完</p>
<p>\2. 四次挥手的Close_wait要怎么解决过多的问题</p>
<p>\3. 好多不记得了</p>
<p>\6. 算法</p>
<p>\1. 找出100个数中的前三个，用哪个方法比较次数最少，比较多少次</p>
<p>\2. 最大堆要比较多少次</p>
<p>\3. 快排多少次</p>
<p>\4. 分治能不能保证第二名一定是排第二的</p>
<p>\5. 二叉树的树高怎么求，公式是怎么推导的</p>
<p>\7. java语言</p>
<p>\1. String s = “中国人”，char数组存，byte存，分别占几个字节 2. String怎么转换成Byte</p>
<p>\3. 这三者1.8种怎么转换的</p>
<p>出自【1】<a name="toc1"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href>参考1</a><a href="#toc1">🔼</a></li>
<li></li>
</ol>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2021/11/08/copy/" title="⭐️copy" class="prev">PREV</a><a href="/2021/04/02/数据结构与算法之美（基础篇）/" title="⭐️数据结构与算法之美（基础篇）" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2021 <a target="_blank">Dufy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/ar-anchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>