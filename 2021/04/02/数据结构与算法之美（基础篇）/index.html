<!DOCTYPE html><html lang="zh-CN//语言"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> ⭐️数据结构与算法之美（基础篇） · Note</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="⭐️数据结构与算法之美（基础篇） - Dufy"><meta name="keywords"><meta name="author" content="Dufy"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Note"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">⭐️数据结构与算法之美（基础篇）</h1><div class="post-info">2021-04-02</div><div class="post-content"><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp84xlwx77j30u01tau05.jpg" alt="img"></p>
<a id="more"></a>

<p>[TOC]</p>
<h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp85qs1hz5j31400u019a.jpg" alt="img"></p>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><ul>
<li><input checked disabled type="checkbox"> 复杂度分析</li>
<li><input checked disabled type="checkbox"> 数组</li>
<li><input checked disabled type="checkbox"> 栈</li>
<li><input checked disabled type="checkbox"> 队列</li>
<li><input checked disabled type="checkbox"> 链表</li>
<li><input checked disabled type="checkbox"> 递归</li>
<li><input checked disabled type="checkbox"> 排序</li>
<li><input checked disabled type="checkbox"> 二分查找</li>
</ul>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ul>
<li><input checked disabled type="checkbox"> 散列表</li>
<li><input checked disabled type="checkbox"> 二叉树</li>
<li><input checked disabled type="checkbox"> 堆</li>
<li><input checked disabled type="checkbox"> 堆排序</li>
<li><input checked disabled type="checkbox"> 字符串匹配</li>
<li><input checked disabled type="checkbox"> Trie🌲</li>
<li><input checked disabled type="checkbox"> 图的表示</li>
</ul>
<h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><ul>
<li><input checked disabled type="checkbox"> 四种算法思想</li>
<li><input checked disabled type="checkbox"> 跳表</li>
</ul>
<h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><ul>
<li><input disabled type="checkbox"> 红黑树</li>
<li><input checked disabled type="checkbox"> 哈希算法</li>
<li><input disabled type="checkbox"> BM/KMP/AC自动机</li>
</ul>
<h2 id="数据结构、算法概念"><a href="#数据结构、算法概念" class="headerlink" title="数据结构、算法概念"></a>数据结构、算法概念</h2><h3 id="什么是数据结构、算法？"><a href="#什么是数据结构、算法？" class="headerlink" title="什么是数据结构、算法？"></a>什么是数据结构、算法？</h3><p>从广义上讲，数据结构是指一组数据的存储结构，算法就是操作数据 的一组方法</p>
<p>从狭义上讲，是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。</p>
<h3 id="二者关系"><a href="#二者关系" class="headerlink" title="二者关系"></a>二者关系</h3><p>数据结构和算法是相辅相成的。<strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上</strong>。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。</p>
<blockquote>
<p>比如，因为数组因为具有随机访问的特点，二分查找就需要用数组来存储数据。如果选择链表，则二分查找算法就无法工作了</p>
</blockquote>
<p>数据结构是<strong>静态</strong>的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。</p>
<p>数据结构是为算法服务的，所以具体选择哪种存储方法，与期望支持的操作有关系</p>
<h3 id="学习原则"><a href="#学习原则" class="headerlink" title="学习原则"></a>学习原则</h3><p><strong>要学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”</strong></p>
<p><strong>很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的</strong>。</p>
<p>学习数据结构最难的不是理解和掌握原理，而是能灵活地将各种场景和问题抽象成对应的数据结构和算法</p>
<p>学习数据结构和算法，并不是为了死记硬背几个知识点。我们的目的是建立时间复杂度、空间复杂 度意识，写出高质􏰁的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此 获得工作回报，实现你的价值，完善你的人生。</p>
<p><strong>掌握了数据结构与算法，你看待问题的深度，解决问题的⻆度就会完全不一样</strong>。因为这样的你，就像是 站在巨人的肩膀上，拿着生存利器行走世界。数据结构与算法，会为你的编程之路，甚至人生之路打开 一扇通往新世界的大⻔。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote>
<p>注意递推公式和递归树求递归复杂度</p>
</blockquote>
<ul>
<li>重要性</li>
</ul>
<p>复杂度分析究竟有多􏰀要呢?可以这么说，它几乎占了数据结构和算法这⻔课的半壁江山，是数据结构和算法学习的<strong>精髓</strong>。</p>
<p>数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考􏰁效率和 资源消耗的方法，这就是复杂度分析方法。所以，如果你只掌握了数据结构和算法的特点、用法，但是 没有学会复杂度分析，那就相当于只知道操作口诀，而没掌握心法。<strong>只有把心法了然于胸，才能做到无 招胜有招!</strong></p>
<ul>
<li>O() 复杂度</li>
</ul>
<p>要理解O() 复杂度 的含义，O()并不表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以大O时间复杂度，也叫渐进时间复杂度，简称时间复杂度。</p>
<blockquote>
<p>更详细的参考：<a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">Know Thy Complexities!</a>：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqk4qum5uyj31hu0t2npd.jpg" alt="image-20210516115644557"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqk4v64747j315a0oy4qp.jpg" alt="image-20210516120055333"></p>
</blockquote>
<ul>
<li>时间复杂度量级</li>
</ul>
<p>分为：</p>
<p>1）多项式量级 </p>
<p>2）非多项式量级（NP, non-deterministic polynomial）</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp979osnjzj313o0ibwqu.jpg" alt="IMG_E5863834E01F-1"></p>
<ul>
<li>空间复杂度</li>
</ul>
<p>我们说空间复杂度的时候<u>，是指除了原本的数据存储空间外</u>，算法运行还需要<strong>额外的</strong>存储空间。</p>
<ul>
<li>最好、最坏和平均情况时间复杂度</li>
</ul>
<p>e.g.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示数组array的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例子代码用于在数组中查找变量 x 的位置</p>
<p>对于最好情况，x 刚好在数组的第一个位置，则复杂度为O(1)；</p>
<p>最差情况，不在数组中，则复杂度为O(n)；</p>
<p>当然，这两种情况都比较极端，发生概率不大。考虑<strong><u>平均时间复杂度</u></strong>，引入<strong>概率分析</strong>。（这里算的是期望）</p>
<blockquote>
<p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。</p>
<p>因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp982ch8m0j313s0ccnap.jpg" alt="image-20210405220945927"></p>
</blockquote>
<p>则最后的平均时间复杂度仍为O(n)</p>
<ul>
<li>均摊时间复杂度</li>
</ul>
<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间<strong>存在前后连贯的时序关系</strong>，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，<strong>一般均摊时间复杂度就等于最好情况时间复杂度</strong>。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>它可以说是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，<strong>最大的特点就是支持随机访问</strong>，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p>
<p>这里需要注意以下几点：</p>
<ul>
<li>第一是<strong>线性表</strong>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。<strong>每个线性表上的数据最多只有前和后两个方向</strong>。其实除了数组，链表、队列、栈等也是线性表结构。【注意这里的‘前后’】</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp99afqpnvj30vq0n5acy.jpg" alt="img"></p>
<p>与之对应，有’非线性表‘，数据之间并不是简单的前后关系，如树，图等</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp99cat1ijj30vq0k7q4w.jpg" alt="img"></p>
<ul>
<li>第二个是连续的内存空间和相同类型的数据—–&gt;<strong>’随机访问‘</strong></li>
</ul>
<p>随机访问的公式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure>

<p>如下，内存块的首地址为 base_address =1000, data_type_size=4B</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp99htxhu5j30vq0g4jso.jpg" alt="img"></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>对于插入，如果数组是有序的， 插入平均复杂度为O(n)【依据概率计算】：（1+2+…+n）/n=O(n)</p>
<p>但是，如果数组存储的数据并没有任何规律，数组只是当做一个存储数据的集合，复杂度可以降为o(1)，如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gp99t9lxiyj31100fg77l.jpg" alt="IMG_A2267639DBED-1"></p>
<p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。</p>
<p>这个处理思想在<strong>快排中也会用到</strong></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>缓存，Cache</li>
</ul>
<p>缓存是一种提高数据读取性能的技术，比如CPU缓存、数据库缓存、浏览器缓存等</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqk3ugftylj30vs06mdrb.jpg" alt="image-20210516112534767"></p>
<p>缓存容量有限，当容量用完时，哪些数据清除和保留就需要一定的策略来决定</p>
<p>缓存淘汰策略一般有三种：</p>
<p>1）先进先出策略 FIFO（First In，First Out）</p>
<p>2）最少使用策略 LFU（Least Frequently Used）</p>
<p>3）最近最少使用策略 <strong>LRU（Least Recently Used）</strong></p>
<h3 id="底层物理结构（与数组对比）"><a href="#底层物理结构（与数组对比）" class="headerlink" title="底层物理结构（与数组对比）"></a>底层物理结构（与数组对比）</h3><p>链表，不需要一块连续的内存空间，通过’指针‘将零散的内存块串联起来使用</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqk42r0cerj31940tghdt.jpg" alt="image-20210516113336149"></p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqkhexjdpdj31fs0awe24.jpg" alt="image-20210516191501331"></p>
<ul>
<li>插入、删除</li>
</ul>
<p>复杂度均为 O(1)</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqkhhuvnggj31cu0cetpj.jpg" alt="image-20210516191749915"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqkhi1d8r7j31b0098dun.jpg" alt="image-20210516191804109"></p>
<p>访问复杂度：O(n)</p>
<ul>
<li>代码实现</li>
</ul>
<p><a href="https://codingdict.com/article/4838" target="_blank" rel="noopener">Python - 链表</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dataval=None)</span>:</span></span><br><span class="line">        self.dataval = dataval</span><br><span class="line">        self.nextval = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.headval = <span class="literal">None</span>   <span class="comment"># 初始化，创建头指针，效果见下图👇</span></span><br><span class="line"></span><br><span class="line">list1 = SLinkedList()</span><br><span class="line">list1.headval = Node(<span class="string">"Mon"</span>)</span><br><span class="line">e2 = Node(<span class="string">"Tue"</span>)</span><br><span class="line">e3 = Node(<span class="string">"Wed"</span>)</span><br><span class="line"><span class="comment"># Link first Node to second node</span></span><br><span class="line">list1.headval.nextval = e2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Link second Node to third node</span></span><br><span class="line">e2.nextval = e3</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpqo6pyz3mj30pc07kgsd.jpg" alt="image-20210421002148400"></p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>跟单链表相比，区别是尾结点指针指向链表的头结点</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpah2ovka4j30vq0b33zb.jpg" alt="img"></p>
<p><strong>循环链表</strong>的优点是从链尾到链头比较方便。当<strong>要处理的数据具有环型结构特点时，就特别适合采用循环链表</strong>。比如著名的约瑟夫问题。尽</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpaha62onoj30vq0b3jun.jpg" alt="image-20210407001412760"></p>
<h3 id="空间换时间与时间换空间"><a href="#空间换时间与时间换空间" class="headerlink" title="空间换时间与时间换空间"></a>空间换时间与时间换空间</h3><p>对于执行较慢的程序，可以通过消耗更多的内存(空间换时间)来进行优化;</p>
<p>而消耗 过多内存的程序，可以通过消耗更多的时间(时间换空间)来降低内存的消耗。、</p>
<h3 id="数组-VS-链表"><a href="#数组-VS-链表" class="headerlink" title="数组 VS 链表"></a>数组 VS 链表</h3><p>正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpahrqpp4qj30rg0dsws2.jpg" alt="image-20210407003106071"></p>
<p>不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂 度分析就决定使用哪个数据结构来存储数据。</p>
<p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p>
<p>链表本身没有大小 的限制，天然地支持动态扩容。</p>
<p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消 耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的 插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会 导致频繁的 GC(Garbage Collection，垃圾回收)。</p>
<p>所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>从栈的操作特性上来看，<strong>栈是一种</strong>“<strong>操作受限</strong>”<strong>的线性表</strong>，只允许在一端插入和删除数据。</p>
<ul>
<li>应用</li>
</ul>
<p>1）函数调用</p>
<p>图中 显示的是，在执行到 add() 函数时，函数调用栈的情况。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpbkmdba7yj31as0n2qv5.jpg" alt="image-20210407225513243"></p>
<p>2）表达式求值</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpbkoah3ybj316r0u0kjl.jpg" alt="image-20210407225706163"></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列跟栈一样，也是一种操作受限的线性表数据结构。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpblh8eafij30xm08uaj3.jpg" alt="image-20210407232456393"></p>
<ul>
<li>数组实现</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpcqnz3ptaj30rk0o67wh.jpg" alt="image-20210408230957735"></p>
<ul>
<li>链表实现</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpblrprhh3j312k0i847d.jpg" alt="IMG_A95FD02F8B3D-1"></p>
<ul>
<li>循环队列</li>
</ul>
<p>用数组实现的循环队列：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpbluvqx8rj30tg0ponhv.jpg" alt="image-20210407233803366"></p>
<ul>
<li>阻塞队列</li>
</ul>
<p>阻塞 队列其实是在队列的基础上增加了阻塞操作。就是在队列为空的时候，从队头取数据会 被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回;如果队列已经满了，那么插入数据 的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpcp7bk14nj31720hatu1.jpg" alt="image-20210408221918674"></p>
<p>利用阻塞队列可以轻松实现一个”生产者-消费者模型“</p>
<p>基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpcpbogzv3j31dy0g4x4n.jpg" alt="image-20210408222332733"></p>
<ul>
<li>并发队列</li>
</ul>
<p>在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢?</p>
<p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加 锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队 列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原 因。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>掌握程度:轻松写出二叉树遍历、八皇后、背包问题、DFS 的递归代码</p>
<ul>
<li>递归的理解</li>
</ul>
<p>递归包括两个过程 ，去的过程叫’递‘，回来的过程叫’归‘，自顶向下。</p>
<ul>
<li>需要满足的三个条件</li>
</ul>
<ol>
<li><p><strong>一个问题的解可以分解为几个子问题的解</strong> </p>
<p>子问题就是数据规模更小的问题。</p>
</li>
<li><p><strong>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</strong></p>
</li>
<li><p><strong>存在递归终止条件</strong> </p>
<p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要</p>
</li>
</ol>
<p>有终止条件。</p>
<ul>
<li>如何写出递归代码</li>
</ul>
<p><strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公 式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</strong>。</p>
<p>写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果要解决问题 A，就假 设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。</p>
<p><strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用 关系，不要试图用人脑去分解递归的每个步骤</strong>。</p>
<ul>
<li>应用举例：找最终推荐人</li>
</ul>
<p>一般来说，我们会通过数据库来记录这种推荐关系。在数据库表中，我们可以记录两行数据，其中 actor_id 表示用户 id，referrer_id 表示推荐人 id。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpcsbloe87j310o0dmwr8.jpg" alt="image-20210409000716444"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">long findRootReferrerId(long actorId) &#123;</span><br><span class="line">  Long referrerId = select referrer_id from [table] where actor_id = actorId;  # 通过这个缩小规模</span><br><span class="line">  if (referrerId == null) return actorId;   # 终止条件</span><br><span class="line">  return findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户 C 的“最终推荐人”为用户 A</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>按照复杂度分为：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqh6vp5meyj310k0le7wh.jpg" alt="image-20210410184545788"></p>
<ul>
<li>原地排序</li>
</ul>
<p>指空间复杂度O(1)的排序算法</p>
<ul>
<li>排序稳定性</li>
</ul>
<p>指的是待排序序列中有值相等的元素，经过排序后，<strong>相等元素之间原有的先后顺序不变</strong>，则称<strong>稳定</strong>的排序算法，否则就叫作不稳定的排序算法</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpev7b92qvj31ct0u07wi.jpg" alt="image-20210410191801301"></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote>
<p>思想：</p>
</blockquote>
<p>通过比较相邻元素，交换位置，每一轮将最值元素通过’冒泡‘浮到边界位置</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpfsgz2v4bj316c0r2npd.jpg" alt="image-20210411142859990"></p>
<p>具体参考：<a href="https://github.com/flitdu/consult/blob/main/jupyter/%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0.ipynb" target="_blank" rel="noopener">consult/jupyter/排序实现.ipynb </a></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 封装函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    n = len(li)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):  <span class="comment"># 比较趟数</span></span><br><span class="line">        tag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n-i):</span><br><span class="line">            <span class="keyword">if</span> li[j]&lt;li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]  <span class="comment"># 交换元素</span></span><br><span class="line">                tag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> tag: <span class="keyword">break</span></span><br><span class="line">li = [random.randint(<span class="number">0</span>,<span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(li)</span><br><span class="line">bubble_sort(li)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度分析：</li>
</ul>
<p>属于原地排序；</p>
<p>由于元素相等时候不进行交换，故为<strong>稳定的；</strong></p>
<p>2个for循环，复杂度O(n^2）</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序是将列表分为两个区：已排序区间和未排序区间。</p>
<p>排序的过程则是不断的从未排序区间取元素，插入到已排序区间。</p>
<p>具体的插入过程，涉及到元素的移动和最后的插入操作</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpf4zjaiovj30nu0jenek.jpg" alt="image-20210411005631807"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">插入排序，分为两个区域：左侧为已排序，右侧为未排序区间</span></span><br><span class="line"><span class="string">原始：4 1 6 5 3 2</span></span><br><span class="line"><span class="string">第一趟： 1 4| 6 5 3 2   选【1】</span></span><br><span class="line"><span class="string">第二趟： 1 4 6| 5 3 2   选【2】</span></span><br><span class="line"><span class="string">....</span></span><br><span class="line"><span class="string">第五趟： 1 2 3 4 5 6|   选【5】</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">li = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">n = len(li)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):  <span class="comment"># 比较的趟数：1，2，3，4，5</span></span><br><span class="line">    value = li[i]  <span class="comment"># 待比较元素</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        print(j, end=<span class="string">'*'</span>)</span><br><span class="line">        <span class="keyword">if</span> li[j]&gt;value:</span><br><span class="line">            li[j+<span class="number">1</span>] = li[j]  <span class="comment"># 移动元素</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        li[j] = value   <span class="comment">#插入数据</span></span><br><span class="line">    print(li)</span><br><span class="line">li</span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度分析：</li>
</ul>
<p>属于原地排序；</p>
<p>由于元素相等时候不进行移动，故为<strong>稳定的；</strong></p>
<p>2个for循环，复杂度O(n^2）</p>
<h3 id="冒泡与插入的比较"><a href="#冒泡与插入的比较" class="headerlink" title="冒泡与插入的比较"></a>冒泡与插入的比较</h3><p>冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地 排序算法，为什么插入排序要比冒泡排序更受欢迎呢?</p>
<p>这是以为具体在操作时候，冒泡涉及到元素的互换，操作次数要多于元素的移动所需的操作次数，具体运行参见下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入与冒泡时间比较</span></span><br><span class="line"><span class="comment"># 随机生成1000个数组，每个 包含100个数据</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_data</span><span class="params">()</span>:</span></span><br><span class="line">    test = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        li = [random.randint(<span class="number">0</span>,<span class="number">20000</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</span><br><span class="line">        test.append(li)</span><br><span class="line">    <span class="keyword">return</span> test</span><br><span class="line">    </span><br><span class="line">test = generate_data()</span><br><span class="line">time0 = time.time()</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> test:</span><br><span class="line">    bubble_sort(li)</span><br><span class="line">print(<span class="string">f'冒泡花费时间：<span class="subst">&#123;time.time()-time0&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">test = generate_data()</span><br><span class="line">time0 = time.time()</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> test:</span><br><span class="line">    insert_sort(li)</span><br><span class="line">print(<span class="string">f'插入花费时间：<span class="subst">&#123;time.time()-time0&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">冒泡花费时间：0.7605938911437988</span><br><span class="line">插入花费时间：0.429502010345459</span><br></pre></td></tr></table></figure>

<p>所以，插入更优</p>
<ul>
<li>综合比较</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpfsqje6ajj31gw0mqx6q.jpg" alt="image-20210411143808882"></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并和快排背后 使用的都是分治思想，而分治算法一般都是用递归实现的。分治是一种解决问题的处理思想， 递归是一种编程技巧，这二者并不冲突。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpfusgjj5vj311t0u0npe.jpg" alt="image-20210411154915840"></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">递归实现：</span></span><br><span class="line"><span class="string">递推公式： merge_sort(p,r) = merge(merge_sort(p,q),merge_sort(q+1, r))</span></span><br><span class="line"><span class="string">终止条件： p&gt;=r</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">li = [<span class="number">3</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(li, p, r)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> p&gt;=r: <span class="keyword">return</span></span><br><span class="line">    mid = (p+r)//<span class="number">2</span>   <span class="comment"># 中间位置</span></span><br><span class="line">    merge_sort(li, p, mid)</span><br><span class="line">    merge_sort(li, mid+<span class="number">1</span>, r)</span><br><span class="line">    merge(li, p, mid, r)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(li, p, mid, r)</span>:</span></span><br><span class="line">    tmp = []  <span class="comment"># 申请临时数组，存放merge 结果</span></span><br><span class="line">    i= p</span><br><span class="line">    j = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;=mid <span class="keyword">and</span> j&lt;=r:</span><br><span class="line">        <span class="keyword">if</span> li[i]&lt;=li[j]:  <span class="comment"># ‘=’保证是稳定的</span></span><br><span class="line">            tmp.append(li[i])</span><br><span class="line">            i +=<span class="number">1</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(li[j])</span><br><span class="line">            j +=<span class="number">1</span></span><br><span class="line">    <span class="comment"># while 执行完肯定有一部分没数了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i&lt;=mid: <span class="comment"># 说明这部分还没取完</span></span><br><span class="line">        tmp.append(li[i])</span><br><span class="line">        i +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;=r: <span class="comment"># 说明这部分还没取完</span></span><br><span class="line">        tmp.append(li[j])</span><br><span class="line">        j +=<span class="number">1</span></span><br><span class="line">    li[p:r+<span class="number">1</span>] = tmp</span><br><span class="line">        </span><br><span class="line">merge_sort(li, <span class="number">0</span>, len(li)<span class="number">-1</span>)</span><br><span class="line">li</span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度分析：</li>
</ul>
<p>空间复杂度O(n), 不属于原地排序；</p>
<p><strong>稳定的</strong>， 可由<code>if li[i]&lt;=li[j]: tmp.append(li[i])</code> 保证</p>
<p>复杂度O(nlg(n)）</p>
<p>分析：</p>
<blockquote>
<p>假设对 n 个元素进行归并排序所需时间为T(n)，则根据归并排序代码</p>
<p>def merge_sort(li, p, r):<br>    pass<br>    if p&gt;=r: return<br>    mid = (p+r)//2   # 中间位置<br>    merge_sort(li, p, mid)     ——– T(n/2)<br>    merge_sort(li, mid+1, r)  ——– T(n/2)<br>    merge(li, p, mid, r)        ——– (n)</p>
<p>可知，T(n) = T(n/2)+T(n/2)+n; n&gt;1</p>
<p>T(n) = C; n=1</p>
<p>T(n) = 2T(n/2)+n=4T(n/4)+2n=8T(n/8)+3n=….=O(nlgn)</p>
</blockquote>
<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p>快排，也是采用分治思想</p>
<p>主要是要分区点的获取，已经分区点的选择水平</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递推公式：</span></span><br><span class="line"><span class="comment"># quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)</span></span><br><span class="line"><span class="comment"># 终止条件：</span></span><br><span class="line"><span class="comment"># p &gt;= r</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(li, p, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p&gt;=r: <span class="keyword">return</span></span><br><span class="line">    q = partition(li, p, r)   <span class="comment"># 获分区点</span></span><br><span class="line">    quick_sort(li, p, q<span class="number">-1</span>)</span><br><span class="line">    quick_sort(li, q+<span class="number">1</span>, r)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(li, p, r)</span>:</span></span><br><span class="line">    pivot = li[p]  <span class="comment"># 选队首为比较点</span></span><br><span class="line">    <span class="keyword">while</span> p&lt;r:</span><br><span class="line">        <span class="keyword">while</span> li[r]&gt;=pivot <span class="keyword">and</span> p&lt;r:</span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        li[p] = li[r]</span><br><span class="line">        <span class="keyword">while</span> li[p] &lt;=pivot <span class="keyword">and</span> p&lt;r:</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        li[r] = li[p]</span><br><span class="line">    li[p] = pivot  <span class="comment"># p/r相遇,得到</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">li = [<span class="number">13</span>,<span class="number">11</span>,<span class="number">25</span>,<span class="number">7</span>,<span class="number">19</span>,<span class="number">3</span>]      </span><br><span class="line">quick_sort(li, <span class="number">0</span>, len(li)<span class="number">-1</span>)</span><br><span class="line">li</span><br></pre></td></tr></table></figure>

<p>关于<code>def partition(li, p, r)   # 获分区点</code>函数的解释：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpg0782djyj314w0rekef.jpg" alt="image-20210411185628255"></p>
<p>快排时间复杂度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1</span><br></pre></td></tr></table></figure>

<p>T(n) = O(nlogn)</p>
<h3 id="快排与归并-的比较"><a href="#快排与归并-的比较" class="headerlink" title="快排与归并 的比较"></a>快排与归并 的比较</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpg0ev9ov4j31do0ti4qq.jpg" alt="image-20210411190349148"></p>
<p>可以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处 理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的 排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并 函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占 用太多内存的问题。</p>
<h3 id="复杂度O-n-排序"><a href="#复杂度O-n-排序" class="headerlink" title="复杂度O(n)排序"></a>复杂度O(n)排序</h3><ul>
<li>桶排序</li>
<li>计数排序</li>
<li>基数排序</li>
</ul>
<p>它们均不涉及元素之间的比较操作</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gphebib1wkj30o806a0vq.jpg" alt="image-20210412235030665"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二分查找</span></span><br><span class="line"><span class="comment"># [1,2,3,5,6,7], tar=1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b_search</span><span class="params">(li, tar)</span>:</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    h = len(li)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> l&lt;=h:</span><br><span class="line">        mid= (h+l)//<span class="number">2</span></span><br><span class="line">        pivot = li[mid]</span><br><span class="line">        <span class="keyword">if</span> tar==pivot: <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> tar&lt;pivot:  <span class="comment"># 缩小h</span></span><br><span class="line">            h=mid<span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>: l=mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">print(b_search(li,<span class="number">6</span>))</span><br></pre></td></tr></table></figure>

<p>递归和非递归代码参见：<a href="https://github.com/flitdu/consult/blob/main/jupyter/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.ipynb" target="_blank" rel="noopener"><strong>二分查找.ipynb</strong> </a></p>
<ul>
<li>适用场景</li>
</ul>
<p>二分查找只能用<strong>在插入、删除操作不频繁，一次排序多次查找的场景中</strong>。针对动态变化的数据集合，二分查找将不再适用。那针对动态数据集合，如何在其中快速查找某个数据呢?别急，等到二叉树 那一节我会详细讲。</p>
<ul>
<li>二分查找变形</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变体一:查找第一个值等于给定值的元素</span><br><span class="line">变体二:查找最后一个值等于给定值的元素</span><br><span class="line">变体三:查找第一个大于等于给定值的元素</span><br><span class="line">变体四:查找最后一个小于等于给定值的元素</span><br></pre></td></tr></table></figure>

<p>参见：<a href="https://github.com/flitdu/consult/blob/main/jupyter/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.ipynb" target="_blank" rel="noopener"><strong>二分查找.ipynb</strong> </a></p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>应用场景：Redis用跳表实现有序集合</p>
<p>跳表是一种各方面性能都比较优秀的<strong>动态数据结构</strong>，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树(Red-black tree)。</p>
<blockquote>
<p>链表+索引 = 跳表：</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpksnctla0j31dy0oge81.jpg" alt="image-20210415222252327"></p>
<ul>
<li>查询时间复杂度</li>
</ul>
<p>假设索引 h 级，最高索引有2个结点。那么整个跳表高度为：log(n)</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkstbauktj31eq0n8hdt.jpg" alt="image-20210415222838932"></p>
<p>单层索引最多需要遍历3个结点，所以整体的复杂度为O(log(n))</p>
<p>此外，插入、删除的复杂度也为O(log(n))</p>
<ul>
<li>空间复杂度</li>
</ul>
<p>将所有索引的节点数相加得到：</p>
<p> n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。</p>
<ul>
<li>索引的动态更新</li>
</ul>
<p>如果不停地往跳表中插入数据，而不更新索引，极端情况下会退化成单链表，如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkt0roo8tj310o0ggdzt.jpg" alt="image-20210415223548875"></p>
<p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链 表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p>
<p>而跳表是<strong>通过随机函数来维护前面提到的“平衡性”</strong>：</p>
<p>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就 将这个结点添加到第一级到第 K 级这 K 级索引中。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkt26cslsj319p0u0npd.jpg" alt="image-20210415223709920"></p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表英文名叫’Hash Table‘，又称’哈希表‘</p>
<p><strong>散列表用的是数组支持下标随机访问数据的特性，所以散列表其实是数组的一种扩展，由数组演化而来</strong>。可以说，没有数组，就没有散列表。</p>
<ul>
<li>原理</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpkusfq4luj315y0pkb29.jpg" alt="image-20210415233700091"></p>
<p>注意，哈希函数哈希的是key ,因此，在dict中查找某个key是否存在操作的时间复杂度为o（1）；查找某个value是否存在操作的时间复杂度为o（n）</p>
<ul>
<li>散列冲突</li>
</ul>
<p>1）开放寻址法</p>
<p>开放寻址法的核心思想是，如果出现了散列冲突，我们就􏰂新探测一个空闲位置，将其插入</p>
<p><a href="https://python123.io/index/topics/data_structure/hash_table" target="_blank" rel="noopener">Python 数据结构入门 - 哈希表（Hash Table）</a></p>
<p>2）链表法</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqh6w5md10j318u0ieu0x.jpg" alt="image-20210420233812543"></p>
<blockquote>
<p>代码实现:</p>
</blockquote>
<p><a href="https://www.pythonf.cn/read/129161" target="_blank" rel="noopener">链式哈希表在Python中的实现,链接,法散,列表,python</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        self.key = key </span><br><span class="line">        self.next = <span class="literal">None</span> </span><br><span class="line">        self.pre = <span class="literal">None</span> </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        value = <span class="string">'&#123;%d&#125;'</span> % (self.key)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    散列表的实现（链接法）</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, T = [])</span>:</span></span><br><span class="line">        self.T = T <span class="comment">#散列表</span></span><br><span class="line">        self.m = len(self.T) <span class="comment">#散列表的容量（槽的数目） </span></span><br><span class="line">        self.size = <span class="number">0</span> <span class="comment">#散列表中所有元素的数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_hash</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="comment">#定义散列函数</span></span><br><span class="line">        <span class="keyword">return</span> abs(key) % self.m</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment">#插入一个节点</span></span><br><span class="line">        k = self._hash(node.key) <span class="comment">#散列值</span></span><br><span class="line">        <span class="keyword">if</span> self.T[k] == <span class="literal">None</span>: <span class="comment">#此链表内没有值的情况</span></span><br><span class="line">            self.T[k] = node </span><br><span class="line">            node.next = <span class="literal">None</span> </span><br><span class="line">            node.pre = <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.next = self.T[k] <span class="comment">#此链表内有值的情况</span></span><br><span class="line">            self.T[k].pre = node </span><br><span class="line">            self.T[k] = node </span><br><span class="line">            self.T[k].pre = <span class="literal">None</span> </span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, key)</span>:</span> <span class="comment">#按关键字搜索</span></span><br><span class="line">        k = self._hash(key)</span><br><span class="line">        current = self.T[k]</span><br><span class="line">        <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> current.key != key:</span><br><span class="line">            current = current.next </span><br><span class="line">        <span class="keyword">if</span> current == <span class="literal">None</span> : <span class="comment">#没有找到时</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"keyerror"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, node)</span>:</span> <span class="comment">#删除散列表的指定节点</span></span><br><span class="line">        k = self._hash(node.key)</span><br><span class="line">        <span class="keyword">if</span> node == self.T[k]:</span><br><span class="line">            self.T[k] == <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">elif</span> node.next == <span class="literal">None</span>:</span><br><span class="line">            node.pre.next = <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.next.pre = node.pre </span><br><span class="line">            node.pre.next = node.next </span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self)</span>:</span> <span class="comment">#可视化散列表</span></span><br><span class="line">        res = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m):</span><br><span class="line">            k = self.T[i]</span><br><span class="line">            line = <span class="string">''</span></span><br><span class="line">            <span class="keyword">while</span> k:</span><br><span class="line">                line += <span class="string">'%s'</span> %k</span><br><span class="line">                k = k.next</span><br><span class="line">                <span class="keyword">if</span> k:</span><br><span class="line">                    line += <span class="string">'&lt;=&gt;'</span></span><br><span class="line">            res[i] = line </span><br><span class="line">        print(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    T = HashTable([<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line">    nodes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">31</span>):</span><br><span class="line">        node = Node(i)</span><br><span class="line">        nodes.append(node)</span><br><span class="line">    T.print()</span><br><span class="line">    T.insert(nodes[<span class="number">0</span>])</span><br><span class="line">    T.print()</span><br><span class="line">    T.insert(nodes[<span class="number">5</span>])</span><br><span class="line">    T.print()</span><br><span class="line">    T.insert(nodes[<span class="number">9</span>])</span><br><span class="line">    T.print()</span><br><span class="line">    T.insert(nodes[<span class="number">10</span>])</span><br><span class="line">    T.print()</span><br><span class="line">    T.insert(nodes[<span class="number">20</span>])</span><br><span class="line">    T.print()</span><br><span class="line">    T.insert(nodes[<span class="number">30</span>])</span><br><span class="line">    T.print()</span><br><span class="line">    T.delete(nodes[<span class="number">20</span>])</span><br><span class="line">    T.print()</span><br><span class="line">输出结果：</span><br><span class="line">[<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br><span class="line">[<span class="string">'&#123;0&#125;'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br><span class="line">[<span class="string">'&#123;0&#125;'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'&#123;5&#125;'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br><span class="line">[<span class="string">'&#123;0&#125;'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'&#123;5&#125;'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'&#123;9&#125;'</span>]</span><br><span class="line">[<span class="string">'&#123;10&#125;&lt;=&gt;&#123;0&#125;'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'&#123;5&#125;'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'&#123;9&#125;'</span>]</span><br><span class="line">[<span class="string">'&#123;20&#125;&lt;=&gt;&#123;10&#125;&lt;=&gt;&#123;0&#125;'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'&#123;5&#125;'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'&#123;9&#125;'</span>]</span><br><span class="line">[<span class="string">'&#123;30&#125;&lt;=&gt;&#123;20&#125;&lt;=&gt;&#123;10&#125;&lt;=&gt;&#123;0&#125;'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'&#123;5&#125;'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'&#123;9&#125;'</span>]</span><br><span class="line">[<span class="string">'&#123;30&#125;&lt;=&gt;&#123;10&#125;&lt;=&gt;&#123;0&#125;'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'&#123;5&#125;'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'&#123;9&#125;'</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>课后题</p>
</blockquote>
<blockquote>
<p>\1. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</p>
<p>遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。</p>
<p>如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; a = &#123;<span class="string">'sdfg'</span>:<span class="number">1</span>, <span class="string">'zzjk'</span>:<span class="number">9</span>, <span class="string">'ooo'</span>:<span class="number">4</span>, <span class="string">'ww.s'</span>:<span class="number">3</span>&#125;</span><br><span class="line">&gt; sorted(a.items(), key = <span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line">&gt; -----------------------------------</span><br><span class="line">&gt; [(<span class="string">'sdfg'</span>, <span class="number">1</span>), (<span class="string">'ww.s'</span>, <span class="number">3</span>), (<span class="string">'ooo'</span>, <span class="number">4</span>), (<span class="string">'zzjk'</span>, <span class="number">9</span>)]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>\2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</p>
<p>以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。</p>
</blockquote>
<ul>
<li>扩容</li>
</ul>
<p>如果散列表的装载因子过大，散列冲突就会变得不可接受，这时可以进行动态扩容，来降低装载因子的大小</p>
<ul>
<li>如何设计工业级的散列表</li>
</ul>
<p><strong>主要考虑：如何设计散列函数，如何根据装载因子动态扩容，以及如何选择散列冲突解决方法：</strong></p>
<p>关于散列函数的设计，我们要尽可能让散列后的值随机且均匀分布，这样会尽可能地减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。除此之外，散列函数的设计也不能太复杂，太复杂就 会太耗时间，也会影响散列表的性能。</p>
<p>关于散列冲突解决方法的选择，我对比了开放寻址法和链表法两种方法的优劣和适应的场景。大部分情 况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如 红黑树，来避免散列表时间复杂度退化成 O(n)，抵御散列碰撞攻击。但是，对于小规模数据、装载因子 不高的散列表，比较适合用开放寻址法。</p>
<p>对于动态散列表来说，不管我们如何设计散列函数，选择什么样的散列冲突解决方法。随着数据的不断 增加，散列表总会出现装载因子过高的情况。这个时候，我们就需要启动动态扩容。</p>
<ul>
<li>散列表和链表的组合使用</li>
</ul>
<blockquote>
<p>案例：LRU缓存淘汰算法</p>
</blockquote>
<p>单链表实现的复杂度为O(n)</p>
<p>借助散列表，实现复杂度O(1):</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprrdtw0puj318c0rinpd.jpg" alt="image-20210421225756369"></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul>
<li>基本概念</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprsbh1igpj30ye0hc1ee.jpg" alt="image-20210421233018284"></p>
<ul>
<li>完全二叉树与满二叉树</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprshh32txj31bc0iw7r0.jpg" alt="image-20210421233605585"></p>
<ul>
<li>二叉树存储</li>
</ul>
<blockquote>
<p>链式存储</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprsjj29roj312w0qwe67.jpg" alt="image-20210421233803644"></p>
<blockquote>
<p>基于数组的顺序存储</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprsnic8hyj312a0liat9.jpg" alt="image-20210421234153502"></p>
<p>如果<strong>某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的</strong>一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单􏰁拎出来的原因，也是为什么完全二叉树要求最后一层的子节点<strong>都靠左</strong>的原因。</p>
<ul>
<li>遍历</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gprtep5idfj31e40j8hdt.jpg" alt="image-20210422000801073"></p>
<p>时间复杂度O(n)，参考递归时间复杂度分析：f(n)=2*f(n/2)+1,且f(1)=1—-&gt;O(n)</p>
<p>层序遍历？？？【结合队列】</p>
<ul>
<li>二叉查找树</li>
</ul>
<p><strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节 点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqh6wj75snj31a80em4fd.jpg" alt="image-20210422233911033"></p>
<p><strong>中序遍历二叉查找树，可以输出有 序的数据序列，时间复杂度是</strong> O(n)<strong>，非常高效</strong>。因此，二叉查找树也叫作二叉排序树。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>需要满足下面两个条件：</p>
<p>1.堆是一个完全二叉树;</p>
<p>2.堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gpsyjbszopj31440u07wh.jpg" alt="image-20210422235059966"></p>
<ul>
<li>堆排序</li>
</ul>
<p>堆排序包括建堆和排 序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的 时间复杂度是 O(nlogn)。</p>
<ul>
<li>堆 的应用</li>
</ul>
<p>优先级队列</p>
<p>队列是先进先出，不过优先级队列则是优先级最高的，最先出队</p>
<h2 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h2><p>Trie <strong>树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起</strong>。</p>
<p>Trie 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。Trie 树比较适 合的是查找前缀匹配的字符串，也就是类似开篇问题的那种场景。</p>
<p>关于 Trie 的应用场景，希望你能记住 8 个字：<strong>一次建树，多次查询</strong>。</p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>哈希算法的定义和原理非常简单，基本上一句话就可以概括了。将任意⻓度的二进制值串映射为固定⻓ 度的二进制值串，这个映射的规则就是<strong>哈希算法</strong>，而通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。</p>
<p>但是，要想设计一个优秀的哈希算法并不容易，需要满足的几点要求:</p>
<ul>
<li>从哈希值不能反向推导出原始数据(所以哈希算法也叫单向哈希算法);</li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同; </li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小; </li>
<li>哈希算法的执行效率要尽􏰃高效，针对较⻓的文本，也能快速地计算出哈希值。</li>
</ul>
<p>应用：</p>
<h3 id="安全加密"><a href="#安全加密" class="headerlink" title="安全加密"></a>安全加密</h3><ul>
<li><p><strong>MD5</strong>(MD5 Message-Digest Algorithm，MD5 消息摘要算法)</p>
</li>
<li><p><strong>SHA</strong>(Secure Hash Algorithm，安全散列算法)</p>
<p>除了这两个之外，当然还有很多其他加密算法，比如 DES(Data Encryption Standard，数据加密标 准)、AES(Advanced Encryption Standard，高级加密标准)。</p>
</li>
</ul>
<p>根据’鸽巢原理‘，哈希算法无法做到零冲突。</p>
<blockquote>
<p>我们知道，哈希算法产生的哈希值的⻓度是固定且有限的。比如前面举的 MD5 的例子，哈希值是固定 的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而我们要哈希的数据是无穷的。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况</p>
</blockquote>
<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><p>Brute Force, 也即暴力匹配算法，复杂度为O（mn），其中m为模式串长度，n 为主串长度，n&gt;m</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gpwd1fyt1sj30vk0eqwzb.jpg" alt="image-20210425222923858"></p>
<h3 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h3><p>RK 算法的全称叫 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。</p>
<p>是BF算法的升级版</p>
<p>RK 算法的思路是这样的：我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了(这 里先不考虑哈希冲突的问题，后面我们会讲到)。因为哈希值是一个数字，数字之间比较是否相等是非 常快速的，所以模式串和子串比较的效率就提高了。</p>
<p>整体复杂度：O(n)</p>
<h3 id="BM-算法"><a href="#BM-算法" class="headerlink" title="BM 算法"></a>BM 算法</h3><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>度：每个用户有多少个好友， 对应到图中，就叫做顶点的<strong>度</strong>(degree)，就是跟顶点相连接的边的条数。</p>
<ul>
<li>有向、无向图</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gpzvkxzh4oj31340ms1kx.jpg" alt="image-20210428232731364"></p>
<ul>
<li>存储</li>
</ul>
<p>邻接矩阵和邻接表</p>
<p>邻接表：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqh6wzd1jdj315c0t0b29.jpg" alt="image-20210428232950016"></p>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><blockquote>
<p>关于BFS和DFS，一个用到了队列，一个用到了递归</p>
<p>注意体会之</p>
</blockquote>
<p>广度优先搜索(Breadth-First-Search)</p>
<p>借助 ’队列‘ 实现</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqh718n6w9j316b0u0qv5.jpg" alt="image-20210513225914579"></p>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>回溯思想</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gq0zutx00oj30t40fialq.jpg" alt="image-20210429224059475"></p>
<h2 id="四种算法思想"><a href="#四种算法思想" class="headerlink" title="四种算法思想"></a>四种算法思想</h2><p>贪心 算法、分治算法、回溯算法、动态规划，更加确切地说，它们应该是算法思想，并不是具体的算法，常用来指导我们设计具体的算法和编码等。</p>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法有很多经典的应用，比如霍夫曼编码(Huffman Coding)、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法</p>
<ul>
<li>霍夫曼编码</li>
</ul>
<p>贪心思想：出现频率多的字符，用稍微短一些的字符编码；出现频率少的字符，用长一些的编码。霍夫曼编码要求各个字符的编码之间，不会出现某个编码是 另一个编码前缀的情况。</p>
<p>具体实现：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqck0ezmfoj316s0u07wj.jpg" alt="image-20210509223800911"></p>
<p>所以，最终的编码为</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqck1wrsyqj30zk0jqx0x.jpg" alt="image-20210509224139300"></p>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>分治算法核心思想：分而治之 ，也就是将原问题划分成 n 个 规模较小，并且结构与原问题相似的子问题，<strong>递归</strong>地解决这些子问题，然后再合并其结果，就得到原问 题的解。</p>
<p>分治算法子问题之间没有相关性，这一点是跟动态规划的明显区别</p>
<ul>
<li>MapReduce</li>
</ul>
<p>MapReduce 本质就是分治思想</p>
<p>一台机器过于低效，那我们就把任务拆分到多台机器上来处理。如果拆分之后的小任务之间互不干扰，独立计算，最后再将结果合并。这不就是分治思想吗?</p>
<p>尽管 MapReduce 的模型非常简单，但是在 Google 内部应用非常广泛。它除了可以用来处理这种数据 与数据之间存在关系的任务，比如 MapReduce 的经典例子，统计文件中单词出现的频率。除此之外， 它还可以用来处理数据与数据之间没有关系的任务，比如对网⻚分析、分词等，每个网⻚可以􏰂立的分 析、分词，而这两个网⻚之间并没有关系。网⻚几十亿、上百亿，如果单机处理，效率低下，我们就可 以利用 MapReduce 提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的 网⻚。</p>
<p>我们也时常感叹 Google 的创新能力如此之强，总是在引领技术的发展。实际上，创新并非离我们很 远，创新的源泉来自对事物本质的认识。无数优秀架构设计的思想来源都是基础的数据结构和算法，这 本身就是算法的一个魅力所在。</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>深度优先搜索算法利用的就是回溯算法思想</p>
<p>笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是􏰃义的指我们前 面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解。</p>
<p>回溯有点类似枚举，非常适合用递归实现。某次尝试出现错误后回到之前的时刻，重新尝试，类似于《蝴蝶效应》</p>
<ul>
<li>N皇后问题</li>
</ul>
<p>参考：<a href="https://www.bilibili.com/video/av374837176/" target="_blank" rel="noopener">合格程序员必会，回溯法解八皇后，看了这个动画，你就全明白了，C++实现</a></p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul>
<li>一个模型三个特征</li>
</ul>
<p>首先，我们来看，什么是“<strong>一个模型</strong>”?它指的是动态规划适合解决的问题的模型。我把这个模型定义为 “<strong>多阶段决策最优解模型</strong>”。下面我具体来给你讲讲。</p>
<p>我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都 对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p>
<p>什么是“<strong>三个特征</strong>”?它们分别是<strong>最优子结构</strong>、<strong>无后效性</strong>和<strong>重复子问题</strong>。</p>
<ul>
<li>两种方法：</li>
</ul>
<blockquote>
<p>状态转移表法</p>
</blockquote>
<p>问题：假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上⻆，终止位置 在右下⻆。我们将棋子从左上⻆移动到右下⻆。每次只能向右或者向下移动一位。从左上⻆到右下⻆， 会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的⻓度。那从左上⻆移动到右 下⻆的<strong>最短路径⻓度</strong>是多少呢?</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqg1vbt5nwj312q0o04qq.jpg" alt="image-20210512231448768"></p>
<blockquote>
<p>状态转移方程法</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>别人的课程索引：<a href="http://173.249.58.195/" target="_blank" rel="noopener">http://173.249.58.195/</a></li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpku2vnsy0j31k20jo1jo.jpg" alt="image-20210415231226060"></p>
<ol start="2">
<li></li>
</ol>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2021/04/04/数据结构与算法之美（加餐）/" title="⭐️数据结构与算法之美（加餐）" class="prev">上一篇</a><a href="/2021/04/02/数据结构与算法之美（高级篇）/" title="⭐️数据结构与算法之美（高级篇 &amp; 实战篇）" class="next">下一篇</a></div><div class="copyright"><p>© 2019 - 2021 <a target="_blank">Dufy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/ar-anchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>